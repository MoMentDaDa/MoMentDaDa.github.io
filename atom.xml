<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MoMent</title>
  
  <subtitle>宁静致远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-27T13:44:02.293Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>汪哒哒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lucene第二篇</title>
    <link href="http://yoursite.com/posts/2d0d7a93.html"/>
    <id>http://yoursite.com/posts/2d0d7a93.html</id>
    <published>2020-07-23T13:51:46.000Z</published>
    <updated>2020-09-27T13:44:02.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、索引库的维护："><a href="#一、索引库的维护：" class="headerlink" title="一、索引库的维护："></a>一、索引库的维护：</h2><p>　　上一篇有介绍过索引库是如何建立以及 filed 的详解。对于索引库的维护，其本质就是对 filed 的增删改。所以理解 filed 对于掌握索引库的维护很重要。话不多说，直接上代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IndexWriter indexWriter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化分析器</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个IndexWriter对象，需要使用IKAnalyzer作为分析器</span></span><br><span class="line">        indexWriter = <span class="keyword">new</span> IndexWriter(FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"F:\\IDEAProject\\JavaWeb\\13_Search\\Index"</span>).toPath()),</span><br><span class="line">                <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> IKAnalyzer()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加域</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDocument</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个IndexWriter对象，需要使用IKAnalyzer作为分析器</span></span><br><span class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(FSDirectory.open(</span><br><span class="line">                <span class="keyword">new</span> File(<span class="string">"F:\\IDEAProject\\JavaWeb\\13_Search\\Index"</span>).toPath()), <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> IKAnalyzer()));</span><br><span class="line">        <span class="comment">//创建一个Document对象</span></span><br><span class="line">        Document document = <span class="keyword">new</span> Document();</span><br><span class="line">        <span class="comment">//向document对象中添加域</span></span><br><span class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"name"</span>, <span class="string">"新添加的文件"</span>, Field.Store.YES));</span><br><span class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"content"</span>, <span class="string">"新添加的文件内容"</span>, Field.Store.NO));</span><br><span class="line">        document.add(<span class="keyword">new</span> StoredField(<span class="string">"path"</span>, <span class="string">"c:/temp/helo"</span>));</span><br><span class="line">        <span class="comment">// 把文档写入索引库</span></span><br><span class="line">        indexWriter.addDocument(document);</span><br><span class="line">        <span class="comment">//关闭索引库</span></span><br><span class="line">        indexWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空域</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAllDocument</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//删除全部文档</span></span><br><span class="line">        indexWriter.deleteAll();</span><br><span class="line">        <span class="comment">//关闭索引库</span></span><br><span class="line">        indexWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定索引</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDocumentByQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        indexWriter.deleteDocuments(<span class="keyword">new</span> Term(<span class="string">"name"</span>, <span class="string">"apache"</span>));</span><br><span class="line">        indexWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新索引，先删除后添加</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDocument</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个新的文档对象</span></span><br><span class="line">        Document document = <span class="keyword">new</span> Document();</span><br><span class="line">        <span class="comment">//向文档对象中添加域</span></span><br><span class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"name"</span>, <span class="string">"更新之后的文档"</span>, Field.Store.YES));</span><br><span class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"name1"</span>, <span class="string">"更新之后的文档2"</span>, Field.Store.YES));</span><br><span class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"name2"</span>, <span class="string">"更新之后的文档3"</span>, Field.Store.YES));</span><br><span class="line">        <span class="comment">//更新操作</span></span><br><span class="line">        indexWriter.updateDocument(<span class="keyword">new</span> Term(<span class="string">"name"</span>, <span class="string">"spring"</span>), document);</span><br><span class="line">        <span class="comment">//关闭索引库</span></span><br><span class="line">        indexWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、搜索结果处理："><a href="#二、搜索结果处理：" class="headerlink" title="二、搜索结果处理："></a>二、搜索结果处理：</h2><p>　　我们常常在网站搜索时，可以看见各个网站都对结果的相关词进行了高亮的处理，在视觉上让人便于查找有搜索对应的文本块，同时界面展示更友好清晰明了。lucene 提供了 highlighter 插件来体现类似的效果，该插件可以对查询关键字高亮处理。</p><p>　　highlighter 包含了用于处理结果页查询内容高亮显示的功能，其中 Highlighter 类 highlighter 包的核心组件，借助 Fragmenter, fragment Scorer, 和 Formatter 等类来支持用户自定义高亮展示的功能；</p><h3 id="A、主程序："><a href="#A、主程序：" class="headerlink" title="A、主程序："></a>A、主程序：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighlighterTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">IndexSearcher searcher;</span><br><span class="line">TopDocs docs; </span><br><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">searcher = SearchUtil.getMultiSearcher(<span class="string">"index"</span>, service);</span><br><span class="line">        Term term = <span class="keyword">new</span> Term(<span class="string">"content"</span>,<span class="keyword">new</span> BytesRef(<span class="string">"lucene"</span>));</span><br><span class="line">        TermQuery termQuery = <span class="keyword">new</span> TermQuery(term);</span><br><span class="line">        docs = SearchUtil.getScoreDocsByPerPage(<span class="number">1</span>, <span class="number">30</span>, searcher, termQuery);</span><br><span class="line">ScoreDoc[] hits = docs.scoreDocs;</span><br><span class="line">        QueryScorer scorer = <span class="keyword">new</span> QueryScorer(termQuery);</span><br><span class="line">        SimpleHTMLFormatter simpleHtmlFormatter = <span class="keyword">new</span> SimpleHTMLFormatter(<span class="string">"&lt;B&gt;"</span>,<span class="string">"&lt;/B&gt;"</span>);<span class="comment">//设定高亮显示的格式&lt;B&gt;keyword&lt;/B&gt;,此为默认的格式  </span></span><br><span class="line">        Highlighter highlighter = <span class="keyword">new</span> Highlighter(simpleHtmlFormatter,scorer);   </span><br><span class="line">        highlighter.setTextFragmenter(<span class="keyword">new</span> SimpleFragmenter(<span class="number">20</span>));<span class="comment">//设置每次返回的字符数</span></span><br><span class="line">        Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hits.length;i++)&#123;   </span><br><span class="line">            Document doc = searcher.doc(hits[i].doc);   </span><br><span class="line">            String str = highlighter.getBestFragment(analyzer, <span class="string">"content"</span>, doc.get(<span class="string">"content"</span>)) ;</span><br><span class="line">            System.out.println(str);   </span><br><span class="line">        &#125;   </span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvalidTokenOffsetsException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">service.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B、评分算法·："><a href="#B、评分算法·：" class="headerlink" title="B、评分算法·："></a>B、评分算法·：</h3><p>　　lucene的highlighter高亮展示的原理：</p><ul><li>根据 Formatter 和 Scorer 创建highlighter对象，formatter 定义了高亮的显示方式，而 scorer 定义了高亮的评分；</li></ul><ul><li>评分的算法是先根据 term 的评分值获取对应的document的权重，在此基础上对文本的内容进行轮询，获取对应的文本出现的次数，和它在term对应的文本中出现的位置（便于高亮处理），评分并分词的算法为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTokenScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position += posIncAtt.getPositionIncrement();<span class="comment">//记录出现的位置</span></span><br><span class="line">    String termText = termAtt.toString();</span><br><span class="line"> </span><br><span class="line">    WeightedSpanTerm weightedSpanTerm;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((weightedSpanTerm = fieldWeightedSpanTerms.get(</span><br><span class="line">              termText)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (weightedSpanTerm.positionSensitive &amp;&amp;</span><br><span class="line">          !weightedSpanTerm.checkPosition(position)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> score = weightedSpanTerm.getWeight();<span class="comment">//获取权重</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// found a query term - is it unique in this doc?</span></span><br><span class="line">    <span class="keyword">if</span> (!foundTerms.contains(termText)) &#123;<span class="comment">//结果排重处理</span></span><br><span class="line">      totalScore += score;</span><br><span class="line">      foundTerms.add(termText);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="C、高亮算法："><a href="#C、高亮算法：" class="headerlink" title="C、高亮算法："></a>C、高亮算法：</h3><p>　　formatter的原理为：对搜索的文本进行判断，如果scorer获取的totalScore不小于0，即查询内容在对应的term中存在，则按照格式拼接成preTag+查询内容+postTag的格式。其默认格式为“<B></B>”的形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">highlightTerm</span><span class="params">(String originalText, TokenGroup tokenGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tokenGroup.getTotalScore() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> originalText;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Allocate StringBuilder with the right number of characters from the</span></span><br><span class="line">    <span class="comment">// beginning, to avoid char[] allocations in the middle of appends.</span></span><br><span class="line">    StringBuilder returnBuffer = <span class="keyword">new</span> StringBuilder(preTag.length() + originalText.length() + postTag.length());</span><br><span class="line">    returnBuffer.append(preTag);</span><br><span class="line">    returnBuffer.append(originalText);</span><br><span class="line">    returnBuffer.append(postTag);</span><br><span class="line">    <span class="keyword">return</span> returnBuffer.toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="D、流程解释："><a href="#D、流程解释：" class="headerlink" title="D、流程解释："></a>D、流程解释：</h3><p>　　Highlighter根据 scorer 和 formatter，对 document 进行分析，查询结果调用 getBestTextFragments，TokenStream、String text、boolean mergeContiguousFragments,int maxNumFragments)，其过程如下：</p><ul><li>scorer首先初始化查询内容对应的出现位置的下标，然后对tokenstream添加PositionIncrementAttribute，此类记录单词出现的位置；</li><li>对文本内容进行轮询，判断查询的文本长度是否超出限制，如果超出文本长度提示过长内容；</li><li>如果获取到指定的文本，先对单次查询的内容进行内容的截取（截取值根据setTextFragmenter指定的值决定），再调用formatter的highlightTerm方法对文本进行重新构建</li><li>在本次轮询和下次单词出现之前对文本内容进行处理</li></ul><h3 id="E、工具类："><a href="#E、工具类：" class="headerlink" title="E、工具类："></a>E、工具类：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">public class SearchUtil &#123;</span><br><span class="line">&#x2F;&#x2F; 获取IndexSearcher对象</span><br><span class="line">public static IndexSearcher getIndexSearcherByParentPath(String parentPath,ExecutorService service) throws IOException&#123;</span><br><span class="line">MultiReader reader &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;设置</span><br><span class="line">try &#123;</span><br><span class="line">File[] files &#x3D; new File(parentPath).listFiles();</span><br><span class="line">IndexReader[] readers &#x3D; new IndexReader[files.length];</span><br><span class="line">for (int i &#x3D; 0 ; i &lt; files.length ; i ++) &#123;</span><br><span class="line">readers[i] &#x3D; DirectoryReader.open(FSDirectory.open(Paths.get(files[i].getPath(), new String[0])));</span><br><span class="line">&#125;</span><br><span class="line">reader &#x3D; new MultiReader(readers);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return new IndexSearcher(reader,service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 多目录多线程查询</span><br><span class="line">public static IndexSearcher getMultiSearcher(String parentPath,ExecutorService service) throws IOException&#123;</span><br><span class="line">File file &#x3D; new File(parentPath);</span><br><span class="line">File[] files &#x3D; file.listFiles();</span><br><span class="line">IndexReader[] readers &#x3D; new IndexReader[files.length];</span><br><span class="line">for (int i &#x3D; 0 ; i &lt; files.length ; i ++) &#123;</span><br><span class="line">readers[i] &#x3D; DirectoryReader.open(FSDirectory.open(Paths.get(files[i].getPath(), new String[0])));</span><br><span class="line">&#125;</span><br><span class="line">MultiReader multiReader &#x3D; new MultiReader(readers);</span><br><span class="line">IndexSearcher searcher &#x3D; new IndexSearcher(multiReader,service);</span><br><span class="line">return searcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据索引路径获取IndexReader</span><br><span class="line">public static DirectoryReader getIndexReader(String indexPath) throws IOException&#123;</span><br><span class="line">return DirectoryReader.open(FSDirectory.open(Paths.get(indexPath, new String[0])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据索引路径获取IndexSearcher</span><br><span class="line">public static IndexSearcher getIndexSearcherByIndexPath(String indexPath,ExecutorService service) throws IOException&#123;</span><br><span class="line">IndexReader reader &#x3D; getIndexReader(indexPath);</span><br><span class="line">return new IndexSearcher(reader,service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果索引目录会有变更用此方法获取新的IndexSearcher这种方式会占用较少的资源</span><br><span class="line">public static IndexSearcher getIndexSearcherOpenIfChanged(IndexSearcher oldSearcher,ExecutorService service) throws IOException&#123;</span><br><span class="line">DirectoryReader reader &#x3D; (DirectoryReader) oldSearcher.getIndexReader();</span><br><span class="line">DirectoryReader newReader &#x3D; DirectoryReader.openIfChanged(reader);</span><br><span class="line">return new IndexSearcher(newReader, service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 多条件查询类似于sql in</span><br><span class="line">public static Query getMultiQueryLikeSqlIn(Query ... querys)&#123;</span><br><span class="line">BooleanQuery query &#x3D; new BooleanQuery();</span><br><span class="line">for (Query subQuery : querys) &#123;</span><br><span class="line">query.add(subQuery,Occur.SHOULD);</span><br><span class="line">&#125;</span><br><span class="line">return query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 多条件查询类似于sql and</span><br><span class="line">public static Query getMultiQueryLikeSqlAnd(Query ... querys)&#123;</span><br><span class="line">BooleanQuery query &#x3D; new BooleanQuery();</span><br><span class="line">for (Query subQuery : querys) &#123;</span><br><span class="line">query.add(subQuery,Occur.MUST);</span><br><span class="line">&#125;</span><br><span class="line">return query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从指定配置项中查询</span><br><span class="line">public static Query getQuery(String field,String fieldType,String queryStr,boolean range)&#123;</span><br><span class="line">Query q &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">if(queryStr !&#x3D; null &amp;&amp; !&quot;&quot;.equals(queryStr))&#123;</span><br><span class="line">if(range)&#123;</span><br><span class="line">String[] strs &#x3D; queryStr.split(&quot;\\|&quot;);</span><br><span class="line">if(&quot;int&quot;.equals(fieldType))&#123;</span><br><span class="line">int min &#x3D; new Integer(strs[0]);</span><br><span class="line">int max &#x3D; new Integer(strs[1]);</span><br><span class="line">q &#x3D; NumericRangeQuery.newIntRange(field, min, max, true, true);</span><br><span class="line">&#125;else if(&quot;double&quot;.equals(fieldType))&#123;</span><br><span class="line">Double min &#x3D; new Double(strs[0]);</span><br><span class="line">Double max &#x3D; new Double(strs[1]);</span><br><span class="line">q &#x3D; NumericRangeQuery.newDoubleRange(field, min, max, true, true);</span><br><span class="line">&#125;else if(&quot;float&quot;.equals(fieldType))&#123;</span><br><span class="line">Float min &#x3D; new Float(strs[0]);</span><br><span class="line">Float max &#x3D; new Float(strs[1]);</span><br><span class="line">q &#x3D; NumericRangeQuery.newFloatRange(field, min, max, true, true);</span><br><span class="line">&#125;else if(&quot;long&quot;.equals(fieldType))&#123;</span><br><span class="line">Long min &#x3D; new Long(strs[0]);</span><br><span class="line">Long max &#x3D; new Long(strs[1]);</span><br><span class="line">q &#x3D; NumericRangeQuery.newLongRange(field, min, max, true, true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(&quot;int&quot;.equals(fieldType))&#123;</span><br><span class="line">q &#x3D; NumericRangeQuery.newIntRange(field, new Integer(queryStr), new Integer(queryStr), true, true);</span><br><span class="line">&#125;else if(&quot;double&quot;.equals(fieldType))&#123;</span><br><span class="line">q &#x3D; NumericRangeQuery.newDoubleRange(field, new Double(queryStr), new Double(queryStr), true, true);</span><br><span class="line">&#125;else if(&quot;float&quot;.equals(fieldType))&#123;</span><br><span class="line">q &#x3D; NumericRangeQuery.newFloatRange(field, new Float(queryStr), new Float(queryStr), true, true);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">Analyzer analyzer &#x3D; new StandardAnalyzer();</span><br><span class="line">q &#x3D; new QueryParser(field, analyzer).parse(queryStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">q&#x3D; new MatchAllDocsQuery();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(q);</span><br><span class="line">&#125; catch (ParseException e) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据field和值获取对应的内容</span><br><span class="line">public static Query getQuery(String fieldName,Object fieldValue)&#123;</span><br><span class="line">Term term &#x3D; new Term(fieldName, new BytesRef(fieldValue.toString()));</span><br><span class="line">return new TermQuery(term);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据IndexSearcher和docID获取默认的document</span><br><span class="line">public static Document getDefaultFullDocument(IndexSearcher searcher,int docID) throws IOException&#123;</span><br><span class="line">return searcher.doc(docID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据IndexSearcher和docID</span><br><span class="line">public static Document getDocumentByListField(IndexSearcher searcher,int docID,Set&lt;String&gt; listField) throws IOException&#123;</span><br><span class="line">return searcher.doc(docID, listField);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 分页查询</span><br><span class="line">public static TopDocs getScoreDocsByPerPage(int page,int perPage,IndexSearcher searcher,Query query) throws IOException&#123;</span><br><span class="line">TopDocs result &#x3D; null;</span><br><span class="line">if(query &#x3D;&#x3D; null)&#123;</span><br><span class="line">System.out.println(&quot; Query is null return null &quot;);</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">ScoreDoc before &#x3D; null;</span><br><span class="line">if(page !&#x3D; 1)&#123;</span><br><span class="line">TopDocs docsBefore &#x3D; searcher.search(query, (page-1)*perPage);</span><br><span class="line">ScoreDoc[] scoreDocs &#x3D; docsBefore.scoreDocs;</span><br><span class="line">if(scoreDocs.length &gt; 0)&#123;</span><br><span class="line">before &#x3D; scoreDocs[scoreDocs.length - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result &#x3D; searcher.searchAfter(before, query, perPage);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">public static TopDocs getScoreDocs(IndexSearcher searcher,Query query) throws IOException&#123;</span><br><span class="line">TopDocs docs &#x3D; searcher.search(query, getMaxDocId(searcher));</span><br><span class="line">return docs;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 高亮显示字段</span><br><span class="line">public static String[] highlighter(IndexSearcher searcher,String field,String keyword,String preTag, String postTag,int fragmentSize) throws IOException, InvalidTokenOffsetsException&#123;</span><br><span class="line">Term term &#x3D; new Term(&quot;content&quot;,new BytesRef(&quot;lucene&quot;));</span><br><span class="line">        TermQuery termQuery &#x3D; new TermQuery(term);</span><br><span class="line">        TopDocs docs &#x3D; getScoreDocs(searcher, termQuery);</span><br><span class="line">        ScoreDoc[] hits &#x3D; docs.scoreDocs;</span><br><span class="line">        QueryScorer scorer &#x3D; new QueryScorer(termQuery);</span><br><span class="line">        SimpleHTMLFormatter simpleHtmlFormatter &#x3D; new SimpleHTMLFormatter(preTag,postTag);&#x2F;&#x2F;设定高亮显示的格式&lt;B&gt;keyword&lt;&#x2F;B&gt;,此为默认的格式  </span><br><span class="line">        Highlighter highlighter &#x3D; new Highlighter(simpleHtmlFormatter,scorer);   </span><br><span class="line">        highlighter.setTextFragmenter(new SimpleFragmenter(fragmentSize));&#x2F;&#x2F;设置每次返回的字符数</span><br><span class="line">        Analyzer analyzer &#x3D; new StandardAnalyzer();</span><br><span class="line">        String[] result &#x3D; new String[hits.length];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; result.length ; i++) &#123;</span><br><span class="line">Document doc &#x3D; searcher.doc(hits[i].doc);</span><br><span class="line">result[i] &#x3D; highlighter.getBestFragment(analyzer, field, doc.get(field));</span><br><span class="line">&#125;</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计document的数量,此方法等同于matchAllDocsQuery查询</span><br><span class="line">public static int getMaxDocId(IndexSearcher searcher)&#123;</span><br><span class="line">return searcher.getIndexReader().maxDoc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、多线程索引建立："><a href="#三、多线程索引建立：" class="headerlink" title="三、多线程索引建立："></a>三、多线程索引建立：</h2><h3 id="A、构建的细节："><a href="#A、构建的细节：" class="headerlink" title="A、构建的细节："></a>A、构建的细节：</h3><p>　　在创建索引的期间有一个 ThreadState 类型的读写锁，lucene 判断 ThreadState 的状态，如果此锁被激活，从内存中获取document并更新到索引文件且重置内存中索引的数量和状态，最后释放相关的资源。lucene 索引的建立，跟以下几点关联很大：</p><ul><li>磁盘空间大小，这个直接影响索引的建立，甚至会造成索引写入提示完成，但是没有同步的问题；</li><li>索引合并策略的选择，这个类似于sql里边的批量操作，批量操作的数量过多直接影响执行效率，对于lucene来讲，索引合并前是将document放在内存中，因此选择合适的合并策略也可以提升索引的效率；</li><li>唯一索引对应的term的选择，lucene索引的创建过程中是先从索引中删除包含相同term的document然后重新添加document到索引中，这里如果term对应的document过多，会占用磁盘IO，同时造成IndexWriter的写锁占用时间延长，相应的执行效率低下； </li></ul><h3 id="B、FileBean："><a href="#B、FileBean：" class="headerlink" title="B、FileBean："></a>B、FileBean：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> # FileBean来存储文件信息，</span><br><span class="line"><span class="keyword">package</span> com.lucene.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileBean</span> </span>&#123;</span><br><span class="line"><span class="comment">//路径</span></span><br><span class="line"><span class="keyword">private</span> String path;</span><br><span class="line"><span class="comment">//修改时间</span></span><br><span class="line"><span class="keyword">private</span> Long modified;</span><br><span class="line"><span class="comment">//内容</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个工具类，用以将文件夹的信息遍历读取并转换成 FileBean 的集合</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtil</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 读取文件信息和下属文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;FileBean&gt; <span class="title">getFolderFiles</span><span class="params">(String folder)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">List&lt;FileBean&gt; fileBeans = <span class="keyword">new</span> LinkedList&lt;FileBean&gt;();</span><br><span class="line">File file = <span class="keyword">new</span> File(folder);</span><br><span class="line"><span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">File[] files = file.listFiles();</span><br><span class="line"><span class="keyword">if</span>(files != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (File file2 : files) &#123;</span><br><span class="line">fileBeans.addAll(getFolderFiles(file2.getAbsolutePath()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">FileBean bean = <span class="keyword">new</span> FileBean();</span><br><span class="line">bean.setPath(file.getAbsolutePath());</span><br><span class="line">bean.setModified(file.lastModified());</span><br><span class="line">bean.setContent(<span class="keyword">new</span> String(Files.readAllBytes(Paths.get(folder))));</span><br><span class="line">fileBeans.add(bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fileBeans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C、索引处理类："><a href="#C、索引处理类：" class="headerlink" title="C、索引处理类："></a>C、索引处理类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lucene.index;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseIndex</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">// 父级索引路径</span></span><br><span class="line"><span class="keyword">private</span> String parentIndexPath;</span><br><span class="line"><span class="comment">// 索引编写器</span></span><br><span class="line"><span class="keyword">private</span> IndexWriter writer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> subIndex;</span><br><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch1;  </span><br><span class="line"><span class="comment">//工作线程 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch2; </span><br><span class="line"><span class="comment">// 对象列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseIndex</span><span class="params">(IndexWriter writer,CountDownLatch countDownLatch1, CountDownLatch countDownLatch2,</span></span></span><br><span class="line"><span class="function"><span class="params">List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.writer = writer;</span><br><span class="line"><span class="keyword">this</span>.countDownLatch1 = countDownLatch1;</span><br><span class="line"><span class="keyword">this</span>.countDownLatch2 = countDownLatch2;</span><br><span class="line"><span class="keyword">this</span>.list = list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseIndex</span><span class="params">(String parentIndexPath, <span class="keyword">int</span> subIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">CountDownLatch countDownLatch1, CountDownLatch countDownLatch2,</span></span></span><br><span class="line"><span class="function"><span class="params">List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.parentIndexPath = parentIndexPath;</span><br><span class="line"><span class="keyword">this</span>.subIndex = subIndex;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//多目录索引创建</span></span><br><span class="line">File file = <span class="keyword">new</span> File(parentIndexPath+<span class="string">"/index"</span>+subIndex);</span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">file.mkdir();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.writer = IndexUtil.getIndexWriter(parentIndexPath+<span class="string">"/index"</span>+subIndex, <span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.subIndex = subIndex;</span><br><span class="line"><span class="keyword">this</span>.countDownLatch1 = countDownLatch1;</span><br><span class="line"><span class="keyword">this</span>.countDownLatch2 = countDownLatch2;</span><br><span class="line"><span class="keyword">this</span>.list = list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseIndex</span><span class="params">(String path,CountDownLatch countDownLatch1, CountDownLatch countDownLatch2,</span></span></span><br><span class="line"><span class="function"><span class="params">List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//单目录索引创建</span></span><br><span class="line">File file = <span class="keyword">new</span> File(path);</span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">file.mkdir();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.writer = IndexUtil.getIndexWriter(path,<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.countDownLatch1 = countDownLatch1;</span><br><span class="line"><span class="keyword">this</span>.countDownLatch2 = countDownLatch2;</span><br><span class="line"><span class="keyword">this</span>.list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建索引</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">indexDoc</span><span class="params">(IndexWriter writer,T t)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 批量索引创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexDocs</span><span class="params">(IndexWriter writer,List&lt;T&gt; t)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (T t2 : t) &#123;</span><br><span class="line">indexDoc(writer,t2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">countDownLatch1.await();</span><br><span class="line">System.out.println(writer);</span><br><span class="line">indexDocs(writer,list);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">countDownLatch2.countDown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer.commit();</span><br><span class="line">writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D、索引创建："><a href="#D、索引创建：" class="headerlink" title="D、索引创建："></a>D、索引创建：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileBeanIndex</span> <span class="keyword">extends</span> <span class="title">BaseIndex</span>&lt;<span class="title">FileBean</span>&gt;</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileBeanIndex</span><span class="params">(IndexWriter writer, CountDownLatch countDownLatch1,</span></span></span><br><span class="line"><span class="function"><span class="params">CountDownLatch countDownLatch2, List&lt;FileBean&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(writer, countDownLatch1, countDownLatch2, list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileBeanIndex</span><span class="params">(String parentIndexPath, <span class="keyword">int</span> subIndex, CountDownLatch countDownLatch1,</span></span></span><br><span class="line"><span class="function"><span class="params">CountDownLatch countDownLatch2, List&lt;FileBean&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parentIndexPath, subIndex, countDownLatch1, countDownLatch2, list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexDoc</span><span class="params">(IndexWriter writer, FileBean t)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Document doc = <span class="keyword">new</span> Document();</span><br><span class="line">System.out.println(t.getPath());</span><br><span class="line">doc.add(<span class="keyword">new</span> StringField(<span class="string">"path"</span>, t.getPath(), Field.Store.YES));</span><br><span class="line">doc.add(<span class="keyword">new</span> LongField(<span class="string">"modified"</span>, t.getModified(), Field.Store.YES));</span><br><span class="line">doc.add(<span class="keyword">new</span> TextField(<span class="string">"content"</span>, t.getContent(), Field.Store.YES));</span><br><span class="line"><span class="keyword">if</span> (writer.getConfig().getOpenMode() == IndexWriterConfig.OpenMode.CREATE)&#123;</span><br><span class="line">        writer.addDocument(doc);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    writer.updateDocument(<span class="keyword">new</span> Term(<span class="string">"path"</span>, t.getPath()), doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E、合并索引："><a href="#E、合并索引：" class="headerlink" title="E、合并索引："></a>E、合并索引：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class IndexUtil &#123;</span><br><span class="line">&#x2F;&#x2F; 创建索引写入器</span><br><span class="line">public static IndexWriter getIndexWriter(String indexPath,boolean create) throws IOException&#123;</span><br><span class="line">Directory dir &#x3D; FSDirectory.open(Paths.get(indexPath, new String[0]));</span><br><span class="line">    Analyzer analyzer &#x3D; new StandardAnalyzer();</span><br><span class="line">    IndexWriterConfig iwc &#x3D; new IndexWriterConfig(analyzer);</span><br><span class="line">    LogMergePolicy mergePolicy &#x3D; new LogByteSizeMergePolicy();</span><br><span class="line">    &#x2F;&#x2F;设置segment添加文档(Document)时的合并频率          &#x2F;&#x2F;值较小,建立索引的速度就较慢          &#x2F;&#x2F;值较大,建立索引的速度就较快,&gt;10适合批量建立索引        </span><br><span class="line">    mergePolicy.setMergeFactor(50);                     </span><br><span class="line">    &#x2F;&#x2F;设置segment最大合并文档(Document)数         </span><br><span class="line">    &#x2F;&#x2F;值较小有利于追加索引的速度         </span><br><span class="line">    &#x2F;&#x2F;值较大,适合批量建立索引和更快的搜索         </span><br><span class="line">    mergePolicy.setMaxMergeDocs(5000);                     </span><br><span class="line">    if (create)&#123;</span><br><span class="line">        iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);</span><br><span class="line">    &#125;</span><br><span class="line">    IndexWriter writer &#x3D; new IndexWriter(dir, iwc);</span><br><span class="line">    return writer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F、测试类："><a href="#F、测试类：" class="headerlink" title="F、测试类："></a>F、测试类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIndex</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">List&lt;FileBean&gt; fileBeans = FileUtil.getFolderFiles(<span class="string">"C:\\Users\\lenovo\\Desktop\\lucene\\lucene-5.1.0"</span>);</span><br><span class="line"><span class="keyword">int</span> totalCount = fileBeans.size();</span><br><span class="line"><span class="keyword">int</span> perThreadCount = <span class="number">3000</span>;</span><br><span class="line">System.out.println(<span class="string">"查询到的数据总数是"</span>+fileBeans.size());</span><br><span class="line"><span class="keyword">int</span> threadCount = totalCount/perThreadCount + (totalCount%perThreadCount == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);  </span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(threadCount);  </span><br><span class="line">CountDownLatch countDownLatch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);  </span><br><span class="line">CountDownLatch countDownLatch2 = <span class="keyword">new</span> CountDownLatch(threadCount);  </span><br><span class="line">System.out.println(fileBeans.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123; </span><br><span class="line"><span class="keyword">int</span> start = i*perThreadCount;</span><br><span class="line"><span class="keyword">int</span> end = (i+<span class="number">1</span>) * perThreadCount &lt; totalCount ? (i+<span class="number">1</span>) * perThreadCount : totalCount;</span><br><span class="line">List&lt;FileBean&gt; subList = fileBeans.subList(start, end);</span><br><span class="line">Runnable runnable = <span class="keyword">new</span> FileBeanIndex(<span class="string">"index"</span>,i, countDownLatch1, countDownLatch2, subList);</span><br><span class="line"><span class="comment">//子线程交给线程池管理  </span></span><br><span class="line">pool.execute(runnable);  </span><br><span class="line">&#125;  </span><br><span class="line">countDownLatch1.countDown();  </span><br><span class="line">System.out.println(<span class="string">"开始创建索引"</span>);  </span><br><span class="line"><span class="comment">//等待所有线程都完成  </span></span><br><span class="line">countDownLatch2.await();  </span><br><span class="line"> <span class="comment">//线程全部完成工作  </span></span><br><span class="line">System.out.println(<span class="string">"所有线程都创建索引完毕"</span>);  </span><br><span class="line"><span class="comment">//释放线程池资源  </span></span><br><span class="line">pool.shutdown();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考博客：</p><p><a href="https://blog.csdn.net/wuyinggui10000/article/details/45898099">https://blog.csdn.net/wuyinggui10000/article/details/45898099</a></p><p><a href="https://blog.csdn.net/wuyinggui10000/category_3173543.html">https://blog.csdn.net/wuyinggui10000/category_3173543.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、索引库的维护：&quot;&gt;&lt;a href=&quot;#一、索引库的维护：&quot; class=&quot;headerlink&quot; title=&quot;一、索引库的维护：&quot;&gt;&lt;/a&gt;一、索引库的维护：&lt;/h2&gt;&lt;p&gt;　　上一篇有介绍过索引库是如何建立以及 filed 的详解。对于索引库的维护，其本质
      
    
    </summary>
    
    
      <category term="搜索框架" scheme="http://yoursite.com/categories/%E6%90%9C%E7%B4%A2%E6%A1%86%E6%9E%B6/"/>
    
      <category term="lucene" scheme="http://yoursite.com/categories/%E6%90%9C%E7%B4%A2%E6%A1%86%E6%9E%B6/lucene/"/>
    
    
      <category term="lucene" scheme="http://yoursite.com/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>lucene第一篇</title>
    <link href="http://yoursite.com/posts/1d1b964b.html"/>
    <id>http://yoursite.com/posts/1d1b964b.html</id>
    <published>2020-07-21T13:44:50.000Z</published>
    <updated>2020-09-27T13:44:09.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Lucene概述："><a href="#一、Lucene概述：" class="headerlink" title="一、Lucene概述："></a>一、Lucene概述：</h2><h3 id="A、基本介绍："><a href="#A、基本介绍：" class="headerlink" title="A、基本介绍："></a>A、基本介绍：</h3><h4 id="1、软件介绍："><a href="#1、软件介绍：" class="headerlink" title="1、软件介绍："></a>1、软件介绍：</h4><p>　　Lucene是apache软件基金会发布的一个开放源代码的全文检索引擎工具包，由资深全文检索专家Doug Cutting所撰写,它是一个<strong>全文检索引擎的架构</strong>，提供了完整的创建索引和查询索引，以及部分文本分析的引擎，Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎，Lucene在全文检索领域是一个经典的祖先，现在很多检索引擎都是在其基础上创建的，思想是相通的。</p><p>　　所以说Lucene 只是一个全文检索的工具包，它不能独立运行，不能单独对外提供服务。然而搜索引擎可以独立运行对外提供搜索服务。另外，Lucene不提供爬虫功能，如果需要获取内容需要自己建立爬虫应用。 Lucene只做索引和搜索工作。</p><p>####2、数据检索方式：</p><p>　　我们生活中的数据总体分为两种：结构化数据和非结构化数据。 结构化数据指具有固定格式或有限长度的数据，如数据库，元数据等。 非结构化数据指不定长或无固定格式的数据，如邮件，word 文档等磁盘上的文件。对于非结构化数据有两种查询方式：</p><ul><li>顺序扫描法：比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下 一个文件，直到扫描完所有的文件。Linux 中的 grep 命令便是这一种方式。该方法对于小数据量的文件，这种方法还是最直接，最方便的。但是对于大量的文件，这种方法就很慢了，如利用windows的搜索也可以搜索文件内容。</li><li>全文检索方式：该方式首先将要查询的目标文档中的词提取出来，组成索引，通过查询索引达到搜索目标文档的目的。这种先建立索引，再对索引进行搜索的过程就叫全文检索。它是指以文本作为检索对象，找出含有指定词汇的文本。全面、准确和快速是衡量全文检索系统的关键指标。</li></ul><h3 id="B、索引介绍："><a href="#B、索引介绍：" class="headerlink" title="B、索引介绍："></a>B、索引介绍：</h3><h4 id="1、索引的由来："><a href="#1、索引的由来：" class="headerlink" title="1、索引的由来："></a>1、索引的由来：</h4><p>　　由于对非结构化数据顺序扫描很慢，对结构化数据的搜索却相对较快是因为可以采取一定的搜索算法加快速度。所以将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有 一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然 后重新组织的信息，我们称之索引。</p><p>　　例如字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某 些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种 可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。 我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据—— 也即对字的解释。</p><h4 id="2、索引的存储内容："><a href="#2、索引的存储内容：" class="headerlink" title="2、索引的存储内容："></a>2、索引的存储内容：</h4><p>　　前面提过索引的由来，当我们查询某一字符串的时候，就相当于查询索引，把字符串和索引一一对比。最后通过符合字符串的索引找到我们需要找的文件。这种从字符串到文件的映射是文件到字符串映射的反向过程，于是保存这种信息的索引称为反向索引。反向索引的所保存的信息一般如下解释：</p><p>　　假设我的文档集合里面有100篇文档，为了方便表示，我们为文档编号从1到100，得到下面的结构</p><p>　　左边保存的是一系列字符串，称为<strong>词典</strong>。每个字符串都指向包含此字符串的文档(Document)链表，此文档链表称为<strong>倒排表</strong>。有了索引，便使保存的信息和要搜索的信息一致，可以大大加快搜索的速度。如说，我们要寻找既包含字符串“lucene”又包含字符串“solr”的文档，我们只需要以下几步：</p><p>　　全文检索的确加快了搜索的速度，但是多了索引的过程，两者加起来不一定比顺序扫描快多少。的确，加上索引的过程，全文检索不一定比顺序扫描快，尤其是在数据量小的时候更是如此。而对一个很大量的数据创建索引也是一个很慢的过程。</p><p>　　然而两者还是有区别的，顺序扫描是每次都要扫描，而创建索引的过程仅仅需要一次，以后便是一劳永逸的了，每次搜索，创建索引的过程不必经过，仅仅搜索创建好的索引就可以了。<strong>这也是全文搜索相对于顺序扫描的优势之一：一次索引，多次使用。</strong></p><p>####　３、创建索引：</p><p>　　最后形成如上图所示的索引链表。所以对词(Term) “allow”来讲，总共有两篇文档包含此词(Term)，从而词(Term)后面的文档链表总共有两项，第一项表示包含“allow”的第一篇文档，即1号文档，此文档中，“allow”出现了2次，第二项表示包含“allow”的第二个文档，是2号文档，此文档中，“allow”出现了1次。</p><h2 id="二、快速入门及使用："><a href="#二、快速入门及使用：" class="headerlink" title="二、快速入门及使用："></a>二、快速入门及使用：</h2><h3 id="A、创建索引库："><a href="#A、创建索引库：" class="headerlink" title="A、创建索引库："></a>A、创建索引库：</h3><h4 id="1、导入依赖："><a href="#1、导入依赖：" class="headerlink" title="1、导入依赖："></a>1、导入依赖：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Lucene核心库 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lucene-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Lucene解析库 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lucene-queryparser&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Lucene附加的分析库 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lucene-analyzers-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--common-io --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--Junit --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2、创建索引库："><a href="#2、创建索引库：" class="headerlink" title="2、创建索引库："></a>2、创建索引库：</h4><ul><li><p><strong>原始文档：</strong>是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等。</p></li><li><p><strong>索引结构：域名:词</strong></p></li><li><p><strong>索引作用：</strong>它里面有指针指向这个词来源的文档</p></li><li><p><strong>-创建文档对象：</strong>获取原始文档的目的是为了索引，在索引前需要将原始内容创建成文档对象（Document），Document中包括一些Field（file_name文件名称、file_path文件路径、file_size文件大小、file_content文件内容），如下图：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建索引库</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//1、创建一个Director对象，指定索引库保存的位置。</span></span><br><span class="line">       <span class="comment">//把索引库保存在内存中</span></span><br><span class="line">       <span class="comment">//Directory directory = new RAMDirectory();</span></span><br><span class="line">       <span class="comment">//把索引库保存在磁盘</span></span><br><span class="line">       Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"F:\\IDEAProject\\JavaWeb\\13_Search\\Index"</span>).toPath());</span><br><span class="line">       <span class="comment">//2、基于Directory对象创建一个IndexWriter对象</span></span><br><span class="line">       <span class="comment">// Lucene 自带中文分词器</span></span><br><span class="line">       IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> IKAnalyzer());  <span class="comment">// 指定分析器，未指定默认为标准分析器</span></span><br><span class="line">       IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, config);</span><br><span class="line">       <span class="comment">//3、读取磁盘上的文件，对应每个文件创建一个文档对象。</span></span><br><span class="line">       File dir = <span class="keyword">new</span> File(<span class="string">"F:\\IDEAProject\\JavaWeb\\13_Search\\searchFiles"</span>);</span><br><span class="line">       File[] files = dir.listFiles();</span><br><span class="line">       <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">           <span class="comment">//取文件名</span></span><br><span class="line">           String fileName = f.getName();</span><br><span class="line">           <span class="comment">//文件的路径</span></span><br><span class="line">           String filePath = f.getPath();</span><br><span class="line">           <span class="comment">//文件的内容</span></span><br><span class="line">           String fileContent = FileUtils.readFileToString(f, <span class="string">"utf-8"</span>);</span><br><span class="line">           <span class="comment">//文件的大小</span></span><br><span class="line">           <span class="keyword">long</span> fileSize = FileUtils.sizeOf(f);</span><br><span class="line">           <span class="comment">//创建Field</span></span><br><span class="line">           <span class="comment">//参数1：域的名称，参数2：域的内容，参数3：是否存储</span></span><br><span class="line">           Field fieldName = <span class="keyword">new</span> TextField(<span class="string">"name"</span>, fileName, Field.Store.YES);</span><br><span class="line">           <span class="comment">//Field fieldPath = new TextField("path", filePath, Field.Store.YES);</span></span><br><span class="line">           Field fieldPath = <span class="keyword">new</span> StoredField(<span class="string">"path"</span>, filePath);</span><br><span class="line">           Field fieldContent = <span class="keyword">new</span> TextField(<span class="string">"content"</span>, fileContent, Field.Store.YES);</span><br><span class="line">           <span class="comment">//Field fieldSize = new TextField("size", fileSize + "", Field.Store.YES);</span></span><br><span class="line">           Field fieldSizeValue = <span class="keyword">new</span> LongPoint(<span class="string">"size"</span>, fileSize);</span><br><span class="line">           Field fieldSizeStore = <span class="keyword">new</span> StoredField(<span class="string">"size"</span>, fileSize);</span><br><span class="line">           <span class="comment">//创建文档对象</span></span><br><span class="line">           Document document = <span class="keyword">new</span> Document();</span><br><span class="line">           <span class="comment">//向文档对象中添加域</span></span><br><span class="line">           document.add(fieldName);</span><br><span class="line">           document.add(fieldPath);</span><br><span class="line">           document.add(fieldContent);</span><br><span class="line">           <span class="comment">//document.add(fieldSize);</span></span><br><span class="line">           document.add(fieldSizeValue);</span><br><span class="line">           document.add(fieldSizeStore);</span><br><span class="line">           <span class="comment">//5、把文档对象写入索引库</span></span><br><span class="line">           indexWriter.addDocument(document);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//6、关闭indexwriter对象</span></span><br><span class="line">       indexWriter.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　IndexWriter 是索引过程的核心组件，通过 IndexWriter 可以创建新索引、更新索引、删除索引操作。IndexWriter 需要通过Directory对索引进行存储操作。<br>　　Directory描述了索引的存储位置，底层封装了I/O操作，负责对索引进行存储。它是一个抽象类，它的子类常用的包括FSDirectory（在文件系统存储索引）、RAMDirectory（在内存存储索引）。</p><h4 id="3、查询索引："><a href="#3、查询索引：" class="headerlink" title="3、查询索引："></a>3、查询索引：</h4><h5 id="a、查询方法："><a href="#a、查询方法：" class="headerlink" title="a、查询方法："></a>a、查询方法：</h5><ul><li>使用Lucene提供Query子类：</li></ul><p>　　Query是一个抽象类，lucene提供了很多查询对象，比如TermQuery项精确查询，NumericRangeQuery数字范围查询等。query子类查询不使用分析器所以建议匹配不分词的Field域查询，比如订单号、分类ID号等。</p><ul><li>使用QueryParse解析查询表达式：</li></ul><p>　　QueryParse会将用户输入的查询表达式解析成Query对象实例。使用该查询方式， 需要使用到分析器。建议创建索引时使用的分析器和查询索引时使用的分析器要一致。同时需要加入 queryParser 依赖的 jar 包。</p><h5 id="b、查询案例："><a href="#b、查询案例：" class="headerlink" title="b、查询案例："></a>b、查询案例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIndexReader2</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> IndexReader indexReader;</span><br><span class="line"> <span class="keyword">private</span> IndexSearcher indexSearch;</span><br><span class="line"> <span class="keyword">private</span> TopDocs topDocs;</span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initIndexSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">FSDirectory fsDirectory=FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"D:/dic"</span>));</span><br><span class="line">indexReader=IndexReader.open(fsDirectory);</span><br><span class="line">indexSearch=<span class="keyword">new</span> IndexSearcher(indexReader);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> ParseException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//指定中文分词器</span></span><br><span class="line">Analyzer analyzer=<span class="keyword">new</span> IKAnalyzer();</span><br><span class="line"><span class="comment">//指定索引库，指定查询条件,有条件则按条件，没有条件则默认</span></span><br><span class="line">QueryParser queryParser=<span class="keyword">new</span> QueryParser(<span class="string">"content"</span>, analyzer);</span><br><span class="line">Query query=queryParser.parse(<span class="string">"project"</span>);</span><br><span class="line"><span class="comment">//查询并遍历结果</span></span><br><span class="line">topDocs=indexSearch.search(query, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用TermQuery查找</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTermQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Query query=<span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">"content"</span>,<span class="string">"project"</span>));</span><br><span class="line">topDocs=indexSearch.search(query, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据数值范围查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNumericRangeQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                                 <span class="comment">//指定域，最小，最大，是否包括最小，是否包括最大值</span></span><br><span class="line">Query query=NumericRangeQuery.newLongRange(<span class="string">"size"</span>, <span class="number">5L</span>, <span class="number">10L</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">topDocs=indexSearch.search(query, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组合查询条件查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBooleanQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">BooleanQuery query = <span class="keyword">new</span> BooleanQuery();</span><br><span class="line"><span class="comment">//名称和内容都包括project的</span></span><br><span class="line">Query query1=<span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">"name"</span>,<span class="string">"project"</span>));</span><br><span class="line">Query query2=<span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">"content"</span>,<span class="string">"project"</span>));</span><br><span class="line">query.add(query1,Occur.MUST);</span><br><span class="line">query.add(query2,Occur.MUST);</span><br><span class="line">topDocs=indexSearch.search(query, <span class="number">6</span>);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Occur参数说明： Occur.MUST : 必须满足查询条件</span></span><br><span class="line"><span class="comment"> * Occur.MUST_NOT : 不满足条件的数据</span></span><br><span class="line"><span class="comment"> * Occur.SHOULD :逻辑OR</span></span><br><span class="line"><span class="comment"> * MUST和MUST：取得连个查询子句的交集。</span></span><br><span class="line"><span class="comment"> * MUST和MUST_NOT：表示查询结果中不能包含MUST_NOT所对应得查询子句的检索结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayAndClose</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"查询总数："</span>+topDocs.totalHits);</span><br><span class="line"><span class="comment">//获得查询结果并遍历</span></span><br><span class="line">ScoreDoc[] scoreDocs=topDocs.scoreDocs;</span><br><span class="line"> <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</span><br><span class="line"> <span class="keyword">int</span> id=scoreDoc.doc;</span><br><span class="line">Document document=indexReader.document(id);</span><br><span class="line">String name=document.get(<span class="string">"name"</span>);</span><br><span class="line">String content=document.get(<span class="string">"content"</span>);</span><br><span class="line">String size=document.get(<span class="string">"size"</span>);</span><br><span class="line">System.out.println(name+content+size);</span><br><span class="line">&#125;</span><br><span class="line">indexReader.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于用户的查询，Lucene只是提供了一个接口而已。Lucene 不提供制作用户搜索界面的功能，需要根据自己的需求开发搜索界面。所以说它是一个工具包，而不是服务。如果需要查询，应该先创建一个查询对象，就想JDBC中查询一样。查询对象中可以指定查询要搜索的 Field 文档域、查询关键字等，查询对象会生成具体的查询语法。根据查询语法在倒排索引词典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。再从链表找到相关的文件，最后就是返回和渲染。</p><h3 id="B、分词器的使用："><a href="#B、分词器的使用：" class="headerlink" title="B、分词器的使用："></a>B、分词器的使用：</h3><p>####1、介绍：</p><p>Lucene 自带两个中文分词器，演示案例感兴趣可以自行百度一下</p><ul><li>标准分析器（StandardAnalyzer）：就是按照中文一个字一个字地进行分词。如：“我爱中国”，效果：“我”、“爱”、“中”、“国”。</li><li>SmartChineseAnalyzer：对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理，需要导入依赖。</li></ul><p>IK Analyzer是一个开源的，基亍java语言开发的轻量级的中文分词工具包。采用了特有的“正向迭代最细粒度切分算法“，支持细粒度和智能分词两种切分模式。2012版本的智能分词模式支持简单的分词排歧义处理和数量词合并输出。采用了多子处理器分析模式。IK Analyzer支持细粒度切分和智能切分两种分词模式;</p><h4 id="4、使用："><a href="#4、使用：" class="headerlink" title="4、使用："></a>4、使用：</h4><p>　　导入依赖，将IKAnalyzer.cfg.xml 和stopword.dic 和 ext.dic 文件复制到工程资源目录下，再进行配置。ext.dic和stopword.dic文件的格式为UTF-8，注意是无BOM 的UTF-8 编码。扩展词汇名字和可以任意，但是得和配置文件一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.janeluo&lt;&#x2F;groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;ikanalyzer&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;version&gt;2012_u6&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分析器的效果演示，标准的默认为每个中文断开，非标准，可以自己更改</span><br><span class="line">    @Test</span><br><span class="line">    public void testTokenStream() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;1）创建一个Analyzer对象，StandardAnalyzer对象，</span><br><span class="line">      &#x2F;&#x2F;  Analyzer analyzer &#x3D; new StandardAnalyzer();</span><br><span class="line"></span><br><span class="line">        Analyzer analyzer &#x3D; new IKAnalyzer();</span><br><span class="line">        &#x2F;&#x2F;2）使用分析器对象的tokenStream方法获得一个TokenStream对象</span><br><span class="line">        TokenStream tokenStream &#x3D; analyzer.tokenStream(&quot;&quot;, &quot;2017年12月14日 - Lucene概述公安局Lucene是一款高性能的、可扩展的信息检索(IR)工具库。信息检索是指文档搜索、文档内信息搜索或者文档相关的元数据搜索等操作。&quot;);</span><br><span class="line">        &#x2F;&#x2F;3）向TokenStream对象中设置一个引用，相当于数一个指针</span><br><span class="line">        CharTermAttribute charTermAttribute &#x3D; tokenStream.addAttribute(CharTermAttribute.class);</span><br><span class="line">        &#x2F;&#x2F;4）调用TokenStream对象的rest方法。如果不调用抛异常</span><br><span class="line">        tokenStream.reset();</span><br><span class="line">        &#x2F;&#x2F;5）使用while循环遍历TokenStream对象</span><br><span class="line">        while (tokenStream.incrementToken()) &#123;</span><br><span class="line">            System.out.println(charTermAttribute.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;6）关闭TokenStream对象</span><br><span class="line">        tokenStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>##三、filed的详细介绍：</p><p>###A、相关属性：</p><p>　　Lucene 存储对象是以 document 为存储单元，对象中相关的属性值则存放到Field中。Filed 具有以下几个属性。</p><ul><li>是否分析：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。</li><li>是否索引：将 Field 分析后的词或整个 Field 值进行索引，只有索引方可搜索到。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。</li><li>是否存储：将 Field 值存储在文档中，存储在文档中的 Field 才可以从 Document 中获取<br>  比如：商品名称、订单号，凡是将来要从 Document 中获取的 Field 都要存储。</li></ul><h3 id="B、常见filed："><a href="#B、常见filed：" class="headerlink" title="B、常见filed："></a>B、常见filed：</h3><h3 id="C、使用案例："><a href="#C、使用案例：" class="headerlink" title="C、使用案例："></a>C、使用案例：</h3><h4 id="1、IntField使用："><a href="#1、IntField使用：" class="headerlink" title="1、IntField使用："></a>1、IntField使用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntFieldTest</span> </span>&#123;</span><br><span class="line"><span class="comment">// 保存一个intField</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIndexIntFieldStored</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Document document = <span class="keyword">new</span> Document();</span><br><span class="line">document.add(<span class="keyword">new</span> IntField(<span class="string">"intValue"</span>, <span class="number">30</span>, Field.Store.YES));</span><br><span class="line"><span class="comment">//要排序必须加同名的field，且类型为NumericDocValuesField</span></span><br><span class="line">document.add(<span class="keyword">new</span> NumericDocValuesField(<span class="string">"intValue"</span>, <span class="number">30</span>));</span><br><span class="line">Document document1 = <span class="keyword">new</span> Document();</span><br><span class="line">document1.add(<span class="keyword">new</span> IntField(<span class="string">"intValue"</span>, <span class="number">40</span>, Field.Store.YES));</span><br><span class="line">document1.add(<span class="keyword">new</span> NumericDocValuesField(<span class="string">"intValue"</span>, <span class="number">40</span>));</span><br><span class="line">IndexWriter writer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer = IndexUtil.getIndexWriter(<span class="string">"intFieldPath"</span>, <span class="keyword">false</span>);</span><br><span class="line">writer.addDocument(document);</span><br><span class="line">writer.addDocument(document1);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer.commit();</span><br><span class="line">writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试intField排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntFieldSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">IndexSearcher searcher = SearchUtil.getIndexSearcher(<span class="string">"intFieldPath"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//构建排序字段</span></span><br><span class="line">SortField[] sortField = <span class="keyword">new</span> SortField[<span class="number">1</span>];</span><br><span class="line">sortField[<span class="number">0</span>] = <span class="keyword">new</span> SortField(<span class="string">"intValue"</span>,SortField.Type.INT,<span class="keyword">true</span>);</span><br><span class="line">Sort sort = <span class="keyword">new</span> Sort(sortField);</span><br><span class="line"><span class="comment">//查询所有结果</span></span><br><span class="line">Query query = <span class="keyword">new</span> MatchAllDocsQuery();</span><br><span class="line">TopFieldDocs docs = searcher.search(query, <span class="number">2</span>, sort);</span><br><span class="line">ScoreDoc[] scores = docs.scoreDocs;</span><br><span class="line"><span class="comment">//遍历结果</span></span><br><span class="line"><span class="keyword">for</span> (ScoreDoc scoreDoc : scores) &#123;</span><br><span class="line">System.out.println(searcher.doc(scoreDoc.doc));;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//searcher.search(query, results);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、LongField使用"><a href="#2、LongField使用" class="headerlink" title="2、LongField使用"></a>2、LongField使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongFieldTest</span> </span>&#123;</span><br><span class="line"><span class="comment">// 保存一个longField</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIndexLongFieldStored</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Document document = <span class="keyword">new</span> Document();</span><br><span class="line">document.add(<span class="keyword">new</span> LongField(<span class="string">"longValue"</span>, <span class="number">50L</span>, Field.Store.YES));</span><br><span class="line">document.add(<span class="keyword">new</span> NumericDocValuesField(<span class="string">"longValue"</span>, <span class="number">50L</span>));</span><br><span class="line">Document document1 = <span class="keyword">new</span> Document();</span><br><span class="line">document1.add(<span class="keyword">new</span> LongField(<span class="string">"longValue"</span>, <span class="number">80L</span>, Field.Store.YES));</span><br><span class="line">document1.add(<span class="keyword">new</span> NumericDocValuesField(<span class="string">"longValue"</span>, <span class="number">80L</span>));</span><br><span class="line">IndexWriter writer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer = IndexUtil.getIndexWriter(<span class="string">"longFieldPath"</span>, <span class="keyword">false</span>);</span><br><span class="line">writer.addDocument(document);</span><br><span class="line">writer.addDocument(document1);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer.commit();</span><br><span class="line">writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试longField排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLongFieldSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">IndexSearcher searcher = SearchUtil.getIndexSearcher(<span class="string">"longFieldPath"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//构建排序字段</span></span><br><span class="line">SortField[] sortField = <span class="keyword">new</span> SortField[<span class="number">1</span>];</span><br><span class="line">sortField[<span class="number">0</span>] = <span class="keyword">new</span> SortField(<span class="string">"longValue"</span>,SortField.Type.LONG,<span class="keyword">true</span>);</span><br><span class="line">Sort sort = <span class="keyword">new</span> Sort(sortField);</span><br><span class="line"><span class="comment">//查询所有结果</span></span><br><span class="line">Query query = <span class="keyword">new</span> MatchAllDocsQuery();</span><br><span class="line">TopFieldDocs docs = searcher.search(query, <span class="number">2</span>, sort);</span><br><span class="line">ScoreDoc[] scores = docs.scoreDocs;</span><br><span class="line"><span class="comment">//遍历结果</span></span><br><span class="line"><span class="keyword">for</span> (ScoreDoc scoreDoc : scores) &#123;</span><br><span class="line"><span class="comment">//System.out.println(searcher.doc(scoreDoc.doc));;</span></span><br><span class="line">Document doc = searcher.doc(scoreDoc.doc);</span><br><span class="line">System.out.println(doc.getField(<span class="string">"longValue"</span>).numericValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//searcher.search(query, results);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、FloatField使用："><a href="#3、FloatField使用：" class="headerlink" title="3、FloatField使用："></a>3、FloatField使用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatFieldTest</span> </span>&#123;</span><br><span class="line"><span class="comment">// 保存一个floatField</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIndexFloatFieldStored</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Document document = <span class="keyword">new</span> Document();</span><br><span class="line">document.add(<span class="keyword">new</span> FloatField(<span class="string">"floatValue"</span>, <span class="number">9.1f</span>, Field.Store.YES));</span><br><span class="line">document.add(<span class="keyword">new</span> FloatDocValuesField(<span class="string">"floatValue"</span>, <span class="number">82.0f</span>));</span><br><span class="line">Document document1 = <span class="keyword">new</span> Document();</span><br><span class="line">document1.add(<span class="keyword">new</span> FloatField(<span class="string">"floatValue"</span>, <span class="number">80.1f</span>, Field.Store.YES));</span><br><span class="line">document1.add(<span class="keyword">new</span> FloatDocValuesField(<span class="string">"floatValue"</span>, <span class="number">80.1f</span>));</span><br><span class="line">IndexWriter writer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer = IndexUtil.getIndexWriter(<span class="string">"floatFieldPath"</span>, <span class="keyword">false</span>);</span><br><span class="line">writer.addDocument(document);</span><br><span class="line">writer.addDocument(document1);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer.commit();</span><br><span class="line">writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试intField排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFloatFieldSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">IndexSearcher searcher = SearchUtil.getIndexSearcher(<span class="string">"floatFieldPath"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//构建排序字段</span></span><br><span class="line">SortField[] sortField = <span class="keyword">new</span> SortField[<span class="number">1</span>];</span><br><span class="line">sortField[<span class="number">0</span>] = <span class="keyword">new</span> SortField(<span class="string">"floatValue"</span>,SortField.Type.FLOAT,<span class="keyword">true</span>);</span><br><span class="line">Sort sort = <span class="keyword">new</span> Sort(sortField);</span><br><span class="line"><span class="comment">//查询所有结果</span></span><br><span class="line">Query query = <span class="keyword">new</span> MatchAllDocsQuery();</span><br><span class="line">TopFieldDocs docs = searcher.search(query, <span class="number">2</span>, sort);</span><br><span class="line">ScoreDoc[] scores = docs.scoreDocs;</span><br><span class="line"><span class="comment">//遍历结果</span></span><br><span class="line"><span class="keyword">for</span> (ScoreDoc scoreDoc : scores) &#123;</span><br><span class="line"><span class="comment">//System.out.println(searcher.doc(scoreDoc.doc));;</span></span><br><span class="line">Document doc = searcher.doc(scoreDoc.doc);</span><br><span class="line">System.out.println(doc.getField(<span class="string">"floatValue"</span>).numericValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//searcher.search(query, results);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、BinaryDocValuesField："><a href="#4、BinaryDocValuesField：" class="headerlink" title="4、BinaryDocValuesField："></a>4、BinaryDocValuesField：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryDocValuesFieldTest</span> </span>&#123;</span><br><span class="line"><span class="comment">// 保存一个BinaryDocValuesField</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIndexLongFieldStored</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Document document = <span class="keyword">new</span> Document();</span><br><span class="line">document.add(<span class="keyword">new</span> BinaryDocValuesField(<span class="string">"binaryValue"</span>,<span class="keyword">new</span> BytesRef(<span class="string">"1234"</span>.getBytes())));</span><br><span class="line">Document document1 = <span class="keyword">new</span> Document();</span><br><span class="line">document1.add(<span class="keyword">new</span> BinaryDocValuesField(<span class="string">"binaryValue"</span>,<span class="keyword">new</span> BytesRef(<span class="string">"2345"</span>.getBytes())));</span><br><span class="line">IndexWriter writer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer = IndexUtil.getIndexWriter(<span class="string">"binaryValueFieldPath"</span>, <span class="keyword">false</span>);</span><br><span class="line">writer.addDocument(document);</span><br><span class="line">writer.addDocument(document1);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer.commit();</span><br><span class="line">writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试BinaryDocValuesField排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBinaryDocValuesFieldSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">IndexSearcher searcher = SearchUtil.getIndexSearcher(<span class="string">"binaryValueFieldPath"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//构建排序字段</span></span><br><span class="line">SortField[] sortField = <span class="keyword">new</span> SortField[<span class="number">1</span>];</span><br><span class="line">sortField[<span class="number">0</span>] = <span class="keyword">new</span> SortField(<span class="string">"binaryValue"</span>,SortField.Type.STRING_VAL,<span class="keyword">true</span>);</span><br><span class="line">Sort sort = <span class="keyword">new</span> Sort(sortField);</span><br><span class="line"><span class="comment">//查询所有结果</span></span><br><span class="line">Query query = <span class="keyword">new</span> MatchAllDocsQuery();</span><br><span class="line">TopFieldDocs docs = searcher.search(query, <span class="number">2</span>, sort);</span><br><span class="line">ScoreDoc[] scores = docs.scoreDocs;</span><br><span class="line"><span class="comment">//遍历结果</span></span><br><span class="line"><span class="keyword">for</span> (ScoreDoc scoreDoc : scores) &#123;</span><br><span class="line"><span class="comment">//System.out.println(searcher.doc(scoreDoc.doc));;</span></span><br><span class="line">Document doc = searcher.doc(scoreDoc.doc);</span><br><span class="line">System.out.println(doc);</span><br><span class="line"><span class="comment">//System.out.println(doc.getField("binaryValue").numericValue());</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//searcher.search(query, results);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、StringField使用："><a href="#5、StringField使用：" class="headerlink" title="5、StringField使用："></a>5、StringField使用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringFieldTest</span> </span>&#123;</span><br><span class="line"><span class="comment">// 保存一个StringField</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIndexLongFieldStored</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Document document = <span class="keyword">new</span> Document();</span><br><span class="line">document.add(<span class="keyword">new</span> StringField(<span class="string">"stringValue"</span>,<span class="string">"12445"</span>, Field.Store.YES));</span><br><span class="line">document.add(<span class="keyword">new</span> SortedDocValuesField(<span class="string">"stringValue"</span>, <span class="keyword">new</span> BytesRef(<span class="string">"12445"</span>.getBytes())));</span><br><span class="line">Document document1 = <span class="keyword">new</span> Document();</span><br><span class="line">document1.add(<span class="keyword">new</span> StringField(<span class="string">"stringValue"</span>,<span class="string">"23456"</span>, Field.Store.YES));</span><br><span class="line">document1.add(<span class="keyword">new</span> SortedDocValuesField(<span class="string">"stringValue"</span>, <span class="keyword">new</span> BytesRef(<span class="string">"23456"</span>.getBytes())));</span><br><span class="line">IndexWriter writer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer = IndexUtil.getIndexWriter(<span class="string">"stringFieldPath"</span>, <span class="keyword">false</span>);</span><br><span class="line">writer.addDocument(document);</span><br><span class="line">writer.addDocument(document1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer.commit();</span><br><span class="line">writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试StringField排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringFieldSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">IndexSearcher searcher = SearchUtil.getIndexSearcher(<span class="string">"stringFieldPath"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//构建排序字段</span></span><br><span class="line">SortField[] sortField = <span class="keyword">new</span> SortField[<span class="number">1</span>];</span><br><span class="line">sortField[<span class="number">0</span>] = <span class="keyword">new</span> SortField(<span class="string">"stringVal"</span>,SortField.Type.STRING,<span class="keyword">true</span>);</span><br><span class="line">Sort sort = <span class="keyword">new</span> Sort(sortField);</span><br><span class="line"><span class="comment">//查询所有结果</span></span><br><span class="line">Query query = <span class="keyword">new</span> MatchAllDocsQuery();</span><br><span class="line">TopFieldDocs docs = searcher.search(query, <span class="number">2</span>, sort);</span><br><span class="line">ScoreDoc[] scores = docs.scoreDocs;</span><br><span class="line"><span class="comment">//遍历结果</span></span><br><span class="line"><span class="keyword">for</span> (ScoreDoc scoreDoc : scores) &#123;</span><br><span class="line"><span class="comment">//System.out.println(searcher.doc(scoreDoc.doc));;</span></span><br><span class="line">Document doc = searcher.doc(scoreDoc.doc);</span><br><span class="line">System.out.println(doc);</span><br><span class="line"><span class="comment">//System.out.println(doc.getField("binaryValue").numericValue());</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//searcher.search(query, results);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、TextField使用："><a href="#6、TextField使用：" class="headerlink" title="6、TextField使用："></a>6、TextField使用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFieldTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 保存一个StringField</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIndexLongFieldStored</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Document document = <span class="keyword">new</span> Document();</span><br><span class="line">document.add(<span class="keyword">new</span> TextField(<span class="string">"textValue"</span>,<span class="string">"12345"</span>, Field.Store.YES));</span><br><span class="line">document.add(<span class="keyword">new</span> SortedDocValuesField(<span class="string">"textValue"</span>, <span class="keyword">new</span> BytesRef(<span class="string">"12345"</span>.getBytes())));</span><br><span class="line">Document document1 = <span class="keyword">new</span> Document();</span><br><span class="line">document1.add(<span class="keyword">new</span> TextField(<span class="string">"textValue"</span>,<span class="string">"23456"</span>, Field.Store.YES));</span><br><span class="line">document1.add(<span class="keyword">new</span> SortedDocValuesField(<span class="string">"textValue"</span>, <span class="keyword">new</span> BytesRef(<span class="string">"23456"</span>.getBytes())));</span><br><span class="line">IndexWriter writer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer = IndexUtil.getIndexWriter(<span class="string">"textFieldPath"</span>, <span class="keyword">false</span>);</span><br><span class="line">writer.addDocument(document);</span><br><span class="line">writer.addDocument(document1);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writer.commit();</span><br><span class="line">writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试StringField排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringFieldSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">IndexSearcher searcher = SearchUtil.getIndexSearcher(<span class="string">"textFieldPath"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//构建排序字段</span></span><br><span class="line">SortField[] sortField = <span class="keyword">new</span> SortField[<span class="number">1</span>];</span><br><span class="line">sortField[<span class="number">0</span>] = <span class="keyword">new</span> SortField(<span class="string">"textValue"</span>,SortField.Type.STRING,<span class="keyword">true</span>);</span><br><span class="line">Sort sort = <span class="keyword">new</span> Sort(sortField);</span><br><span class="line"><span class="comment">//查询所有结果</span></span><br><span class="line">Query query = <span class="keyword">new</span> MatchAllDocsQuery();</span><br><span class="line">TopFieldDocs docs = searcher.search(query, <span class="number">2</span>, sort);</span><br><span class="line">ScoreDoc[] scores = docs.scoreDocs;</span><br><span class="line"><span class="comment">//遍历结果</span></span><br><span class="line"><span class="keyword">for</span> (ScoreDoc scoreDoc : scores) &#123;</span><br><span class="line"><span class="comment">//System.out.println(searcher.doc(scoreDoc.doc));;</span></span><br><span class="line">Document doc = searcher.doc(scoreDoc.doc);</span><br><span class="line">System.out.println(doc);</span><br><span class="line"><span class="comment">//System.out.println(doc.getField("binaryValue").numericValue());</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//searcher.search(query, results);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考博客</strong>：</p><p><a href="https://juejin.im/entry/56c6ca55816dfa00598ddb25">https://juejin.im/entry/56c6ca55816dfa00598ddb25</a></p><p><a href="https://juejin.im/post/5aaf21d46fb9a028b86dcf38#heading-7">https://juejin.im/post/5aaf21d46fb9a028b86dcf38#heading-7</a></p><p><a href="https://juejin.im/post/5abde676f265da23a049abb6#heading-4">https://juejin.im/post/5abde676f265da23a049abb6#heading-4</a></p><p><a href="https://blog.csdn.net/wuyinggui10000/article/details/45538155">https://blog.csdn.net/wuyinggui10000/article/details/45538155</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Lucene概述：&quot;&gt;&lt;a href=&quot;#一、Lucene概述：&quot; class=&quot;headerlink&quot; title=&quot;一、Lucene概述：&quot;&gt;&lt;/a&gt;一、Lucene概述：&lt;/h2&gt;&lt;h3 id=&quot;A、基本介绍：&quot;&gt;&lt;a href=&quot;#A、基本介绍：&quot; c
      
    
    </summary>
    
    
      <category term="搜索框架" scheme="http://yoursite.com/categories/%E6%90%9C%E7%B4%A2%E6%A1%86%E6%9E%B6/"/>
    
      <category term="lucene" scheme="http://yoursite.com/categories/%E6%90%9C%E7%B4%A2%E6%A1%86%E6%9E%B6/lucene/"/>
    
    
      <category term="lucene" scheme="http://yoursite.com/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>Nginx第二篇</title>
    <link href="http://yoursite.com/posts/dfa3bea2.html"/>
    <id>http://yoursite.com/posts/dfa3bea2.html</id>
    <published>2020-07-11T07:08:06.000Z</published>
    <updated>2020-09-27T13:44:19.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Nginx-原理："><a href="#一、Nginx-原理：" class="headerlink" title="一、Nginx 原理："></a>一、Nginx 原理：</h2><h3 id="A、模块划分："><a href="#A、模块划分：" class="headerlink" title="A、模块划分："></a>A、模块划分：</h3><h4 id="1、从结构上划分："><a href="#1、从结构上划分：" class="headerlink" title="1、从结构上划分："></a>1、从结构上划分：</h4><p>　　Nginx由内核和模块组成，其中，内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。</p><p>　　 Nginx的模块从结构上分为核心模块、基础模块和第三方模块：</p><ul><li><p>核心模块：HTTP模块、EVENT模块和MAIL模块</p></li><li><p>基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块，</p></li><li><p>第三方模块：HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块。</p></li></ul><p>　　用户根据自己的需要开发的模块都属于第三方模块。正是有了这么多模块的支撑，Nginx的功能才会如此强大。</p><h4 id="2、从功能上划分："><a href="#2、从功能上划分：" class="headerlink" title="2、从功能上划分："></a>2、从功能上划分：</h4><p>Nginx的模块从功能上分为如下三类。</p><ul><li><p>Handlers（处理器模块）。此类模块直接处理请求，并进行输出内容和修改headers信息等操作。Handlers处理器模块一般只能有一个。</p></li><li><p>Filters （过滤器模块）。此类模块主要对其他处理器模块输出的内容进行修改操作，最后由Nginx输出。</p></li><li><p>Proxies （代理类模块）。此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与后端一些服务比如FastCGI等进行交互，实现服务代理和负载均衡等功能。</p></li></ul><pre><code>{% asset_img image-20200711181613552.png image-20200711181613552 %}</code></pre><p>　　Nginx本身做的工作实际很少，当它接到一个HTTP请求时，它仅仅是通过查找配置文件将此次请求映射到一个location block，而此location中所配置的各个指令则会启动不同的模块去完成工作，因此模块可以看做Nginx真正的劳动工作者。通常一个location中的指令会涉及一个handler模块和多个filter模块（当然，多个location可以复用同一个模块）。handler模块负责处理请求，完成响应内容的生成，而filter模块对响应内容进行处理。</p><p>　　Nginx的模块直接被编译进Nginx，因此属于静态编译方式。启动Nginx后，Nginx的模块被自动加载，不像Apache，首先将模块编译为一个so文件，然后在配置文件中指定是否进行加载。在解析配置文件时，Nginx的每个模块都有可能去处理某个请求，但是同一个处理请求只能由一个模块来完成。 </p><h3 id="B、工作流程："><a href="#B、工作流程：" class="headerlink" title="B、工作流程："></a>B、工作流程：</h3><h4 id="1、模型介绍："><a href="#1、模型介绍：" class="headerlink" title="1、模型介绍："></a>1、模型介绍：</h4><p>　　Nginx 采用的是多进程（单线程） &amp; 多路IO复用模型。使用了 I/O 多路复用技术的 Nginx，就成了”并发事件驱动“的服务器。所，Nginx分为单工作进程和多工作进程两种工作模式。在单工作进程模式下，除主进程外，还有一个工作进程，工作进程是单线程的；在多工作进程模式下，每个工作进程包含多个线程。Nginx默认为单工作进程模式。</p><p>　　　　<strong>1、Nginx 在启动后，会有一个 master 进程和多个相互独立的 worker 进程。</strong></p><p>　　　　<strong>2、接收来自外界的信号，向各worker进程发送信号，每个进程都有可能来处理这个连接。</strong><br>　　　　<strong>3、 master 进程能监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动启动新的 worker 进程。</strong></p><p>惊群现象：</p><p>　　　主进程（master 进程）首先通过 socket() 来创建一个 sock 文件描述符用来监听，然后fork生成子进程（workers 进程），子进程将继承父进程的 sockfd（socket 文件描述符），之后子进程 accept() 后将创建已连接描述符（connected descriptor）），然后通过已连接描述符来与客户端通信。</p><p>　　　由于所有子进程都继承了父进程的 sockfd，那么当连接进来时，所有子进程都将收到通知并“争着”与它建立连接，这就叫“惊群现象”。大量的进程被激活又挂起，只有一个进程可以accept() 到这个连接，这当然会消耗系统资源。</p><p>Nginx对惊群现象的处理：<br>　　　Nginx 提供了一个 accept_mutex 这个东西，这是一个加在accept上的一把共享锁。当一个请求到达的时候，即每个 worker 进程在执行 accept 之前都需要先获取锁，获取不到就放弃执行 accept()。简而言之，只有竞争到锁的worker进程才会惊醒处理请求，其他进程会继续等待。有了这把锁之后，同一时刻，就只会有一个进程去 accpet()，这样就不会有惊群问题了。accept_mutex 是一个可控选项，我们可以显示地关掉，默认是打开的。</p><h4 id="2、进程介绍："><a href="#2、进程介绍：" class="headerlink" title="2、进程介绍："></a>2、进程介绍：</h4><h5 id="a、master进程"><a href="#a、master进程" class="headerlink" title="a、master进程:"></a>a、master进程:</h5><p>　　该进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。</p><p>　　master进程充当整个进程组与用户的交互接口，同时对进程进行监护。它不需要处理网络事件，不负责业务的执行，只会通过管理worker进程来实现重启服务、平滑升级、更换日志文件、配置文件实时生效等功能。以下以重启为例解释：</p><h5 id="b、worker进程"><a href="#b、worker进程" class="headerlink" title="b、worker进程:"></a>b、worker进程:</h5><p>　　对于基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求,所以得到请求的机会都是相等的，同时各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致。因为nginx为了更好的利用多核特性，具有cpu绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。</p><p><strong>1.</strong>   <strong>当我们提供80端口的http服务时，一个连接请求过来。首先，每个worker进程都是从master进程fork过来，在master进程里面，先建立好需要listen的socket（listenfd），再fork出多个worker进程。</strong></p><p><strong>2.</strong>   <strong>所有worker进程的listenfd会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有worker进程在注册listenfd读事件前抢accept_mutex，抢到互斥锁的那个进程注册listenfd读事件，在读事件里调用accept接受该连接</strong></p><p><strong>3.</strong>   <strong>当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了</strong></p><p>这样做带来的好处：<br>　　节省锁带来的开销。每个 worker 进程都是独立的进程，不共享资源，不需要加锁。同时在编程以及问题查上时，也会方便很多。<br>　　独立进程，减少风险。采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快重新启动新的 worker 进程。当然，worker 进程的也能发生意外退出。<br>　　如果不使用 IO 多路复用，那么在一个进程中，同时只能处理一个请求，比如执行 accept()，如果没有连接过来，那么程序会阻塞在这里，直到有一个连接过来，才能继续向下执行。而多路复用，允许我们只在事件发生时才将控制返回给程序，而其他时候内核都挂起进程，随时待命。</p><h2 id="二、高可用的简单搭建"><a href="#二、高可用的简单搭建" class="headerlink" title="二、高可用的简单搭建"></a>二、高可用的简单搭建</h2><h3 id="A、相关概念了解："><a href="#A、相关概念了解：" class="headerlink" title="A、相关概念了解："></a>A、相关概念了解：</h3><h4 id="1、负载均衡高可用："><a href="#1、负载均衡高可用：" class="headerlink" title="1、负载均衡高可用："></a>1、<strong>负载均衡高可用</strong>：</h4><p>　　nginx作为负载均衡器，所有请求都到了nginx（对外服务的唯一入口，唯一公网IP），可见nginx处于非常重点的位置，如果nginx服务器宕机后端web服务将无法提供服务，影响严重。</p><p>　　为了屏蔽负载均衡服务器的宕机风险，需要建立一个备份机。主服务器和备份机上都运行高可用监控程序，通过传送诸如“I am alive”这样的信息来监控对方的运行状况。当备份机不能在一定的时间内收到这样的信息时，它就接管主服务器的服务IP并继续提供负载均衡服务；当备份管理器又从主管理器收到“I am alive”这样的信息时，它就释放服务IP地址，这样的主服务器就开始再次提供负载均衡服务。高可用的开源软件有：heartbeat、Keepalived，其中heartbeat已无人维护，所以今后使用Keepalived来搭建高可用集群。</p><h4 id="2、Keepalived介绍："><a href="#2、Keepalived介绍：" class="headerlink" title="2、Keepalived介绍："></a>2、Keepalived介绍：</h4><h5 id="a、软件介绍："><a href="#a、软件介绍：" class="headerlink" title="a、软件介绍："></a>a、软件介绍：</h5><p>　　keepalived是集群管理中保证集群高可用的一个服务软件，用来防止单点故障。Keepalived的作用是检测web服务器的状态（健康监测），如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的web服务器从系统中剔除，当web服务器工作正常后Keepalived自动将web服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的web服务器。</p><h5 id="b、工作原理："><a href="#b、工作原理：" class="headerlink" title="b、工作原理："></a>b、工作原理：</h5><p>　　keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（虚拟IP地址，该路由器所在局域网内其他机器的默认路由为该vip）。</p><p>　　　master会不断地发送组播心跳消息，当backup收不到VRRP包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。当为抢占模式时MASTER从故障中恢复后，会将VIP从BACKUP节点中抢占过来。非抢占模式时MASTER恢复后不抢占BACKUP升级为MASTER后的VIP。</p><p>　　keepalived主要有三个模块，分别是core、check和VRRP。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。VRRP模块是来实现VRRP协议的。</p><h5 id="c、工作方式："><a href="#c、工作方式：" class="headerlink" title="c、工作方式："></a>c、工作方式：</h5><p>　　第一种是主从模式，适用于国企、政府类系统。使用一个vip地址，前端使用2台机器，一台做主，一台做备，但同时只有一台机器工作，另一台备份机器在主机器不出现故障的时候，永远处于浪费状态，对于服务器不多的网站，该方案不经济实惠。</p><p>　　第二种是双主模式，一般使用两个vip地址，前端使用2台机器，互为主备，同时有两台机器工作，当其中一台机器出现故障，两台机器的请求转移到一台机器负担，非常适合于当前架构环境。</p><h5 id="d、安装："><a href="#d、安装：" class="headerlink" title="d、安装："></a>d、安装：</h5><p><strong>tar安装：</strong></p><p>　　从官网<a href="http://www.keepalived.org/download.html">下载keepalived</a>的最新版本，然后上传至虚拟机或者服务器，或者直接下载到本地也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;www.keepalived.org&#x2F;software&#x2F;keepalived-1.2.24.tar.gz</span><br></pre></td></tr></table></figure><p>　　输入命令  tar -zxf keepalived-1.4.2.tar.gz  解压。从源编译指定prefix，对 ./configure 进行设置，最后make &amp;&amp; make install 编译安装。</p><p><strong>yum 安装：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived -y</span><br><span class="line">rpm -q -a keepalived # 查看版本</span><br></pre></td></tr></table></figure><p><strong>配置文件简介：</strong></p><p>　　keepalived服务安装完成之后，后面的主要工作就是在keepalived.conf文件中配置HA和负载均衡。一个功能比较完整的常用的keepalived配置文件，主要包含三块：全局定义块、VRRP实例定义块和虚拟服务器定义块。全局定义块是必须的，如果keepalived只用来做ha，虚拟服务器是可选的。下面是一个功能比较完整的配置文件模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#全局定义块</span><br><span class="line">global_defs &#123;</span><br><span class="line">    # 邮件通知配置</span><br><span class="line">    notification_email &#123;</span><br><span class="line">        email1</span><br><span class="line">        email2</span><br><span class="line">    &#125;</span><br><span class="line">    notification_email_from email</span><br><span class="line">    smtp_server host</span><br><span class="line">    smtp_connect_timeout num</span><br><span class="line"></span><br><span class="line">    lvs_id string</span><br><span class="line">    router_id string    ## 标识本节点的字条串,通常为hostname</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#VRRP 实例定义块</span><br><span class="line">vrrp_sync_group string &#123; </span><br><span class="line">    group &#123;</span><br><span class="line">        string</span><br><span class="line">        string</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance string &#123;</span><br><span class="line">    state MASTER|BACKUP</span><br><span class="line">    virtual_router_id num</span><br><span class="line">    interface string</span><br><span class="line">    mcast_src_ip @IP </span><br><span class="line">    priority num</span><br><span class="line">    advert_int num</span><br><span class="line">    nopreempt</span><br><span class="line">    smtp_alert</span><br><span class="line">    lvs_sync_daemon_interface string </span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS|AH</span><br><span class="line">        auth_pass string</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;  # Block limited to 20 IP addresses @IP</span><br><span class="line">        @IP</span><br><span class="line">        @IP</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#虚拟服务器定义块</span><br><span class="line">virtual_server (@IP PORT)|(fwmark num) &#123; </span><br><span class="line">    delay_loop num</span><br><span class="line">    lb_algo rr|wrr|lc|wlc|sh|dh|lblc </span><br><span class="line">    lb_kind NAT|DR|TUN</span><br><span class="line">    persistence_timeout num </span><br><span class="line">    protocol TCP|UDP</span><br><span class="line">    real_server @IP PORT &#123; </span><br><span class="line">        weight num</span><br><span class="line">        notify_down &#x2F;path&#x2F;script.sh</span><br><span class="line">        TCP_CHECK &#123; </span><br><span class="line">            connect_port num </span><br><span class="line">            connect_timeout num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server @IP PORT &#123;</span><br><span class="line">        weight num</span><br><span class="line">        MISC_CHECK &#123;</span><br><span class="line">            misc_path &#x2F;path_to_script&#x2F;script.sh(or misc_path “&#x2F;path_to_script&#x2F;script.sh &lt;arg_list&gt;”)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server @IP PORT &#123;</span><br><span class="line">        weight num</span><br><span class="line">        HTTP_GET|SSL_GET &#123;</span><br><span class="line">            url &#123; </span><br><span class="line">                # You can add multiple url block path alphanum</span><br><span class="line">                digest alphanum</span><br><span class="line">            &#125;</span><br><span class="line">            connect_port num</span><br><span class="line">            connect_timeout num </span><br><span class="line">            nb_get_retry num </span><br><span class="line">            delay_before_retry num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B、高可用的实现："><a href="#B、高可用的实现：" class="headerlink" title="Ｂ、高可用的实现："></a>Ｂ、高可用的实现：</h3><h4 id="1、主从模式介绍："><a href="#1、主从模式介绍：" class="headerlink" title="1、主从模式介绍："></a>1、主从模式介绍：</h4><p>　　这张图的意思是，我们使用keepalived来管理两台设备的Nginx，并虚拟出一个IP，我们现在两台装有Nginx的设备分别是192.168.101.3和192.168.101.4，那么我们可以虚拟出一个192.168.156.xx的IP，外界请求直接访问虚拟IP而不是真正的Nginx，让虚拟IP去访问提供服务的Nginx（注意：高可用是指同一时间提供服务的只有一台设备，提供服务的设备挂掉之后，备份服务器便开始提供服务），然后再由Nginx去访问tomcat。</p><h4 id="2、实验过程："><a href="#2、实验过程：" class="headerlink" title="2、实验过程："></a>2、实验过程：</h4><h5 id="a、修改配置文件："><a href="#a、修改配置文件：" class="headerlink" title="a、修改配置文件："></a>a、修改配置文件：</h5><p>　　修改/etc/keepalived/keepalivec.conf 配置文件，需要注意主备的 state 和 priority 两个属性的值。一般而言只需要将备用机的 state设置为 BACKUP ，同时降低 priority 的值即可。Nginx配置参考前面教程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">        cold_night@linuxzen.com             # 定义通知邮箱,有多个可以换行添加</span><br><span class="line">&#125;</span><br><span class="line">   notification_email_from root@linuxzen.com# 定义发送邮件的邮箱</span><br><span class="line">   smtp_server www.linuxzen.com             # 定义发件服务器</span><br><span class="line">   smtp_connect_timeout 30                  # 定义连接smtp服务器超时时间</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER                   # 标示主备,备机上改为BACKUP</span><br><span class="line">    interface eth0                 # HA监测的端口</span><br><span class="line">    virtual_router_id 51           # 主备的virtual_router_id的值必须相同</span><br><span class="line">    priority 100                   # 优先级,通常主要比备稍大，备机较小</span><br><span class="line">    advert_int 1                   # VRRP Multicast 广播周期秒数</span><br><span class="line">    authentication &#123;               # 定义认证</span><br><span class="line">        auth_type PASS             # 认证方式</span><br><span class="line">        auth_pass 1111             # 认证口令字</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;            # 定义vip</span><br><span class="line">        192.168.3.253              # 多个可换行添加,一行一个</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.3.253 80 &#123;</span><br><span class="line">    delay_loop 6             # 每隔 6 秒查询 realserver 状态</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    nat_mask 255.255.255.0</span><br><span class="line">    persistence_timeout 50   # 同一IP 的连接50秒内被分配到同一台realserver</span><br><span class="line">    protocol TCP             # 用TCP监测realserver的状态</span><br><span class="line"></span><br><span class="line">    real_server 192.168.3.1 80 &#123;</span><br><span class="line">        weight 3                # 权重</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_timeout 10  # 10秒无响应超时</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">            connect_port 80</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server 192.168.3.2 80 &#123;</span><br><span class="line">        weight 3</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">            connect_port 80</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b、添加监测脚本："><a href="#b、添加监测脚本：" class="headerlink" title="b、添加监测脚本："></a>b、添加监测脚本：</h5><p>　　在/usr/local/src 添加检测脚本，脚本必须通过授权，不然没权限访问啊。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#检测nginx是否启动了</span><br><span class="line">A&#x3D;&#96;ps -C nginx --no-header |wc -l&#96;        </span><br><span class="line">if [ $A -eq 0 ];then    #如果nginx没有启动就启动nginx                        </span><br><span class="line">      systemctl start nginx                #重启nginx</span><br><span class="line">      if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then    #nginx重启失败，则停掉keepalived服务，进行VIP转移</span><br><span class="line">              killall keepalived                    </span><br><span class="line">      fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">chmod 775 check_nginx_pid.sh  #脚本授权命令</span><br><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;keepalived.log  #查看日志</span><br><span class="line">ps -ef | grep keepalived  # 查看进程信息</span><br><span class="line">service keepalived start  # 启动 keepalived </span><br><span class="line">service keepalived stop  # 停止 keepalived</span><br><span class="line">service keepalived restart  # 重启服务</span><br></pre></td></tr></table></figure><h5 id="c、启动测试："><a href="#c、启动测试：" class="headerlink" title="　c、启动测试："></a>　c、启动测试：</h5><p>　　把两台服务器上 nginx 和 keepalived 启动。在浏览器地址栏输入虚拟 ip 地址 192.168.17.50测试服务是否有用。同时查看网卡信息，是否有虚拟IP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动 nginx：.&#x2F;nginx</span><br><span class="line">启动 keepalived：systemctl start keepalived.service</span><br></pre></td></tr></table></figure><p>　　把主服务器（192.168.17.129）nginx 和 keepalived 停止，再输入 192.168.17.50。查看服务是否还可以正常提供。同时查看备份机会不会生成虚拟 IP。如果再次重启主节点，主节点会再次将虚拟IP抢夺回来。</p><h5 id="d、补充："><a href="#d、补充：" class="headerlink" title="d、补充："></a>d、补充：</h5><p>　　在Keepalived集群中，其实并没有严格意义上的主、备节点，虽然可以在Keepalived配置文件中设置“state”选项为“MASTER”状态，但是这并不意味着此节点一直就是Master角色。控制节点角色的是Keepalived配置文件中的“priority”值，但并它并不控制所有节点的角色，另一个能改变节点角色的是在vrrp_script模块中设置的“weight”值，这两个选项对应的都是一个整数值，其中“weight”值可以是个负整数，一个节点在集群中的角色就是通过这两个值的大小决定的。</p><p>　　在一个一主多备的 Keepalived 集群中，“priority”值最大的将成为集群中的Master节点，而其他都是Backup节点。在Master节点发生故障后，Backup节点之间将进行“民主选举”，通过对节点优先级值“priority”和““weight”的计算，选出新的Master节点接管集群服务。</p><p>　　在vrrp_script模块中，如果不设置“weight”选项值，那么集群优先级的选择将由Keepalived配置文件中的“priority”值决定，而在需要对集群中优先级进行灵活控制时，可以通过在vrrp_script模块中设置“weight”值来实现。下面列举一个实例来具体说明。</p><p>　　假定有A和B两节点组成的Keepalived集群，在A节点keepalived.conf文件中，设置“priority”值为100，而在B节点keepalived.conf文件中，设置“priority”值为80，并且A、B两个节点都使用了“vrrp_script”模块来监控nginx服务，同时都设置“weight”值为10，那么将会发生如下情况：</p><p>　　在两节点都启动Keepalived服务后，正常情况是A节点将成为集群中的Master节点，而B自动成为Backup节点，此时将A节点的nginx服务关闭，通过查看日志发现，并没有出现B节点接管A节点的日志，B节点仍然处于Backup状态，而A节点依旧是Master状态，在这种情况下整个HA集群将失去意义。</p><blockquote><p>参考博客：</p><p><a href="https://blog.csdn.net/m0_38110132/article/details/75126316">https://blog.csdn.net/m0_38110132/article/details/75126316</a></p><p><a href="https://blog.csdn.net/hguisu/article/details/8930668">https://blog.csdn.net/hguisu/article/details/8930668</a></p><p><a href="http://www.uml.org.cn/zjjs/201808214.asp">http://www.uml.org.cn/zjjs/201808214.asp</a></p><p><a href="https://juejin.im/entry/5b21c4d3f265da6e3423c69a">https://juejin.im/entry/5b21c4d3f265da6e3423c69a</a></p><p><a href="https://blog.csdn.net/xyang81/article/details/52554398">https://blog.csdn.net/xyang81/article/details/52554398</a></p><p><a href="https://blog.csdn.net/qq_40036754/article/details/102463099">https://blog.csdn.net/qq_40036754/article/details/102463099</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Nginx-原理：&quot;&gt;&lt;a href=&quot;#一、Nginx-原理：&quot; class=&quot;headerlink&quot; title=&quot;一、Nginx 原理：&quot;&gt;&lt;/a&gt;一、Nginx 原理：&lt;/h2&gt;&lt;h3 id=&quot;A、模块划分：&quot;&gt;&lt;a href=&quot;#A、模块划分：&quot; c
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/JavaWeb/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 第一篇</title>
    <link href="http://yoursite.com/posts/cf99e1c1.html"/>
    <id>http://yoursite.com/posts/cf99e1c1.html</id>
    <published>2020-07-06T12:35:39.000Z</published>
    <updated>2020-09-27T13:44:14.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Nginx-介绍："><a href="#一、Nginx-介绍：" class="headerlink" title="一、Nginx 介绍："></a>一、Nginx 介绍：</h2><h3 id="A、概述："><a href="#A、概述：" class="headerlink" title="A、概述："></a>A、概述：</h3><h4 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>Nginx是世界上第二大Web服务器，其他Web服务器有：Apache、Lighttpd、Tomcat、Jetty、IIS。</p><p>区别：</p><ul><li>Tomcat、Jetty面向Java语言，先天就是重量级的Web服务器，他们的性能与Nginx没有可比性；</li><li>IIS只能在Windows操作系统上运行；</li><li>Apache发展时期最长，是毫无争议的第一大Web服务器，然而它被设计为一个重量级的、不支持高并发的Web服务器，这决定了Apache不可能成为高性能Web服务器。</li><li>Nginx是俄罗斯的Igor Sysoev用C语言开发的 跨平台的支持高并发的Web服务器，以性能为王。</li></ul><h4 id="2、特点："><a href="#2、特点：" class="headerlink" title="2、特点："></a><strong>2、特点：</strong></h4><ul><li>更快。一方面单次请求将会得到更快的响应；另一方面 在数以万计的并发请求时，Nginx比其他Web服务器更快的响应请求。</li><li>高扩展性。它完全由不同功能、不同层次、不同类别且耦合度极低的模块组成。</li><li>高可靠性。nginx的高可靠性来自于其核心框架代码的优秀设计、模块设计的简单性。</li><li>低内存消耗。1万个非活跃的Http Keep-Alive连接在Nginx中仅消耗2.5MB的内存，这是nginx支持高并发连接的基础。</li><li>单机支持10万以上的并发连接。</li><li>热部署。7X24小时不间断的服务的前提下，升级nginx的可执行文件。</li><li>最自由的BSD许可协议。用户不仅免费使用nginx，而且可以参与修改源代码</li></ul><p>选择Nginx的核心理由是：它能够在支持高并发请求的同时 保持高效的服务。Nginx先天的事件驱动型设计、全异步的网络I/O处理机制、极少的进程间切换以及许多优化设计，使得它天生善于处理高并发压力下的互联网请求。</p><h3 id="B、安装教程："><a href="#B、安装教程：" class="headerlink" title="B、安装教程："></a>B、安装教程：</h3><h4 id="1、window-安装："><a href="#1、window-安装：" class="headerlink" title="1、window 安装："></a>1、window 安装：</h4><h5 id="a、安装教程："><a href="#a、安装教程：" class="headerlink" title="a、安装教程："></a>a、安装教程：</h5><p>　　进入官网<a href="https://www.cnblogs.com/taiyonghai/p/nginx.org">nginx.org</a>，直接直接下载相应的文件。分别有Linux和Windows两个版本。点击后就会下载，下载完成后开始安装，其实官网已经告诉了如何安装，右侧“documentation -&gt; nginx windows”就有详细的说明，只是英文而已。</p><p>下载相应的文件，解压到响应的目录即完成安装。使用cmd命令进行操作，不可以直接双击nginx.exe。不要直接双击nginx.exe，不要直接双击nginx.exe</p><p>　　一定要在dos窗口启动，不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程，再启动才可以。</p><p><strong>1、使用命令到达nginx的加压缩后的目录*</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd c:\nginx<span class="number">-1.15</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p><strong>2、启动nginx服务，启动时会一闪而过是正常的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nginx</span><br></pre></td></tr></table></figure><p><strong>3、查看任务进程是否存在，dos或打开任务管理器都行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist &#x2F;fi &quot;imagename eq nginx.exe&quot;</span><br></pre></td></tr></table></figure><p>　　打开任务管理器在进程中看不到nginx.exe的进程（双击nginx.exe时会显示在这里），需要打开详细信息里面能看到隐藏的nginx.exe进程</p><p>​      如果都没有可能是启动报错了查看一下日志，在nginx目录中的logs文件夹下error.log是日志文件</p><h5 id="b、常见错误："><a href="#b、常见错误：" class="headerlink" title="b、常见错误："></a>b、常见错误：</h5><p><strong>a、端口占用 ：</strong></p><p>　　修改配置文件，进入解压缩目录，直接文件夹点击进去即可，不需要从dos操作。具体操作如图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -t -c &#x2F;nginx-1.15.2&#x2F;conf&#x2F;nginx.conf   &#x2F;&#x2F; 检查配置文件是否正确</span><br><span class="line">nginx -s reload  &#x2F;&#x2F;如果没有关闭程序，可以直接重新加载配置文件</span><br><span class="line">http:&#x2F;&#x2F;localhost:8800   &#x2F;&#x2F;浏览器访问既可以查看是否启动成功</span><br></pre></td></tr></table></figure><h4 id="2、Linux安装-："><a href="#2、Linux安装-：" class="headerlink" title="2、Linux安装 ："></a>2、Linux安装 ：</h4><p><strong>1、下载相应的依赖组件</strong>：</p><p>　　需要安装 gcc 的环境，如果没有安装，需要安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><p>　　下载openssl主要用于ssl模块加密，支持htps。确保系统已经安装了wget，如果没有安装，执行 yum install wget 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.0.2s.tar.gz </span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><p>　　下载<code>pcre</code>来实现对地址重定向，地址重写功能和localtion指令以及正则表达式的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;ftp.pcre.org&#x2F;pub&#x2F;pcre&#x2F;pcre-8.43.tar.gz</span><br><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><p>　　下载<code>zlib</code> gzip压缩模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.11.tar.gz</span><br><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><p>　　下载Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.17.1.tar.gz</span><br></pre></td></tr></table></figure><p>　　解压所有的安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls *.tar.gz | xargs -n1 tar xzvf    &#x2F;&#x2F;解压全部压缩包</span><br><span class="line">tar –xvf pcre-8.37.tar.gz  &#x2F;&#x2F;解压单个文件</span><br></pre></td></tr></table></figure><p><strong>2、编译选项</strong>：</p><p>　　使用<code>./configure</code>设置各种Nginx参数的脚本，包括源和配置文件的路径，编译器选项，连接处理方法和模块列表。该脚本通过创建编译代码和安装Nginx开源所需的Makefile来完成。vi /usr/local/nginx/conf/nginx.conf</p><p>　　然后进行编译安装，</p><p>　　输入./nginx 启动程序。输入网址进行查看。如果有防火墙阻挡，按以下命令设置防火墙即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep nginx &#x2F;&#x2F; 查看Nginx进程</span><br><span class="line">nginx -s stop   &#x2F;&#x2F;  快速关闭</span><br><span class="line">nginx -s quit   &#x2F;&#x2F; 安全有序的关闭 </span><br><span class="line">&#x2F;nginx -s reload  &#x2F;&#x2F;重新加载配置文件</span><br><span class="line">.&#x2F;nginx -v  &#x2F;&#x2F;  查看 nginx 版本号</span><br><span class="line">chmod +x &#x2F;etc&#x2F;rc.d&#x2F;rc.local  &#x2F;&#x2F; 配置开机自启</span><br><span class="line">whereis nginx  &#x2F;&#x2F; 查看安装路径</span><br><span class="line"></span><br><span class="line">service iptables stop  &#x2F;&#x2F;关闭防火墙</span><br><span class="line">chkconfig iptables off  关闭开机自启动防火墙</span><br><span class="line">firewall-cmd --list-all &#x2F;&#x2F; 查看开放的端口号</span><br><span class="line">firewall-cmd --add-service&#x3D;http –permanent</span><br><span class="line">firewall-cmd --add-port&#x3D;80&#x2F;tcp --permanent  &#x2F;&#x2F;设置开放的端口号，设置完成需要重启</span><br><span class="line">firewall-cmd –reload  &#x2F;&#x2F;重启防火墙</span><br><span class="line">netstat -tlnp &#x2F;&#x2F; 查看端口号</span><br></pre></td></tr></table></figure><h2 id="二、配置文件："><a href="#二、配置文件：" class="headerlink" title="二、配置文件："></a>二、配置文件：</h2><h3 id="A、文件结构介绍："><a href="#A、文件结构介绍：" class="headerlink" title="A、文件结构介绍："></a>A、文件结构介绍：</h3><p>　　包含全局块，events块和http块（http块包含http全局块和多个server块-server块又包含server全局块和location块）;如下所示:</p><p>　　外层的指令可以作用于自身的块和此块中的所有低层级块，并且还遵循低级优于高级，类似于Java中的全局变量和局部变量。</p><p>　　各模块的作用：</p><h3 id="B、文件介绍："><a href="#B、文件介绍：" class="headerlink" title="B、文件介绍："></a>B、文件介绍：</h3><p>　　参数和详细配置说明，请参考<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#server">官方文档</a>，以下为常用配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line">#定义Nginx运行的用户和用户组</span><br><span class="line">user www www; </span><br><span class="line"></span><br><span class="line">#nginx进程数，通常设置成和cpu的数量相等</span><br><span class="line">worker_processes 4; </span><br><span class="line"></span><br><span class="line">#全局错误日志定义类型，[debug | info | notice | warn | error | crit]</span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#进程pid文件</span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定进程可以打开的最大描述符：数目</span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span><br><span class="line">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    #参考事件模型，use [ kqueue | rtsig | epoll | &#x2F;dev&#x2F;poll | select | poll ]; epoll模型</span><br><span class="line">    #是Linux 2.6以上版本内核中的高性能网络I&#x2F;O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">    #补充说明：</span><br><span class="line">    #与apache相类，nginx针对不同的操作系统，有不同的事件模型</span><br><span class="line">    #A）标准事件模型</span><br><span class="line">    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span><br><span class="line">    #B）高效事件模型</span><br><span class="line">    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span><br><span class="line">    #Epoll：使用于Linux内核2.6版本及以后的系统。</span><br><span class="line">    #&#x2F;dev&#x2F;poll：使用于Solaris 7 11&#x2F;99+，HP&#x2F;UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span><br><span class="line">    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span><br><span class="line">    use epoll</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    #单个进程最大连接数（最大连接数&#x3D;连接数+进程数）</span><br><span class="line">    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    </span><br><span class="line">    #keepalive 超时时间</span><br><span class="line">    keepalive_timeout 60;</span><br><span class="line">    </span><br><span class="line">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span><br><span class="line">    #分页大小可以用命令getconf PAGESIZE 取得。</span><br><span class="line">    #[root@web001 ~]# getconf PAGESIZE</span><br><span class="line">    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line">    </span><br><span class="line">    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br><span class="line">    open_file_cache max&#x3D;65535 inactive&#x3D;60s;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    #这个是指多长时间检查一次缓存的有效信息。</span><br><span class="line">    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span><br><span class="line">    open_file_cache_valid 80s;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span><br><span class="line">    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span><br><span class="line">    open_file_cache_min_uses 1;</span><br><span class="line">    </span><br><span class="line">    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span><br><span class="line">    open_file_cache_errors on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="line">http&#123;</span><br><span class="line">    #文件扩展名与文件类型映射表</span><br><span class="line">    include mime.types;</span><br><span class="line">    </span><br><span class="line">    #默认文件类型</span><br><span class="line">    default_type application&#x2F;octet-stream;</span><br><span class="line">    </span><br><span class="line">    #默认编码</span><br><span class="line">    charset utf-8;</span><br><span class="line">    </span><br><span class="line">    #服务器名字的hash表大小</span><br><span class="line">    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line">    </span><br><span class="line">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br><span class="line">    client_header_buffer_size 32k;</span><br><span class="line">    </span><br><span class="line">    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span><br><span class="line">    large_client_header_buffers 4 64k;</span><br><span class="line">    </span><br><span class="line">    #设定通过nginx上传文件的大小</span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line">    </span><br><span class="line">    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I&#x2F;O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span><br><span class="line">    sendfile on;</span><br><span class="line">    </span><br><span class="line">     #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">    autoindex on;</span><br><span class="line">    </span><br><span class="line">      #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">     </span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    </span><br><span class="line">    #长连接超时时间，单位是秒</span><br><span class="line">    keepalive_timeout 120;</span><br><span class="line">    </span><br><span class="line">    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line">    </span><br><span class="line">    #gzip模块设置</span><br><span class="line">    gzip on; #开启gzip压缩输出</span><br><span class="line">    gzip_min_length 1k;    #最小压缩文件大小</span><br><span class="line">    gzip_buffers 4 16k;    #压缩缓冲区</span><br><span class="line">    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    gzip_comp_level 2;     #压缩等级</span><br><span class="line">    gzip_types text&#x2F;plain application&#x2F;x-javascript text&#x2F;css application&#x2F;xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    #开启限制IP连接数的时候需要使用</span><br><span class="line">    #limit_zone crawler $binary_remote_addr 10m;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    #负载均衡配置</span><br><span class="line">    upstream piao.jd.com &#123;</span><br><span class="line">     </span><br><span class="line">        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">        server 192.168.80.121:80 weight&#x3D;3;</span><br><span class="line">        server 192.168.80.122:80 weight&#x3D;2;</span><br><span class="line">        server 192.168.80.123:80 weight&#x3D;3;</span><br><span class="line"></span><br><span class="line">        #nginx的upstream目前支持4种方式的分配</span><br><span class="line">        #1、轮询（默认）</span><br><span class="line">        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><br><span class="line">        #2、weight</span><br><span class="line">        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br><span class="line">        #例如：</span><br><span class="line">        #upstream bakend &#123;</span><br><span class="line">        #    server 192.168.0.14 weight&#x3D;10;</span><br><span class="line">        #    server 192.168.0.15 weight&#x3D;10;</span><br><span class="line">        #&#125;</span><br><span class="line">        #2、ip_hash</span><br><span class="line">        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><br><span class="line">        #例如：</span><br><span class="line">        #upstream bakend &#123;</span><br><span class="line">        #    ip_hash;</span><br><span class="line">        #    server 192.168.0.14:88;</span><br><span class="line">        #    server 192.168.0.15:80;</span><br><span class="line">        #&#125;</span><br><span class="line">        #3、fair（第三方）</span><br><span class="line">        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br><span class="line">        #upstream backend &#123;</span><br><span class="line">        #    server server1;</span><br><span class="line">        #    server server2;</span><br><span class="line">        #    fair;</span><br><span class="line">        #&#125;</span><br><span class="line">        #4、url_hash（第三方）</span><br><span class="line">        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span><br><span class="line">        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span><br><span class="line">        #upstream backend &#123;</span><br><span class="line">        #    server squid1:3128;</span><br><span class="line">        #    server squid2:3128;</span><br><span class="line">        #    hash $request_uri;</span><br><span class="line">        #    hash_method crc32;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        #tips:</span><br><span class="line">        #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span><br><span class="line">        #    ip_hash;</span><br><span class="line">        #    server 127.0.0.1:9090 down;</span><br><span class="line">        #    server 127.0.0.1:8080 weight&#x3D;2;</span><br><span class="line">        #    server 127.0.0.1:6060;</span><br><span class="line">        #    server 127.0.0.1:7070 backup;</span><br><span class="line">        #&#125;</span><br><span class="line">        #在需要使用负载均衡的server中增加 proxy_pass http:&#x2F;&#x2F;bakend&#x2F;;</span><br><span class="line"></span><br><span class="line">        #每个设备的状态设置为:</span><br><span class="line">        #1.down表示单前的server暂时不参与负载</span><br><span class="line">        #2.weight为weight越大，负载的权重就越大。</span><br><span class="line">        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span><br><span class="line">        #4.fail_timeout:max_fails次失败后，暂停的时间。</span><br><span class="line">        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><span class="line"></span><br><span class="line">        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span><br><span class="line">        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span><br><span class="line">        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span><br><span class="line">        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    #虚拟主机的配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #监听端口</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name www.jd.com jd.com;</span><br><span class="line">        #默认入口文件名称</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        root &#x2F;data&#x2F;www&#x2F;jd;</span><br><span class="line"></span><br><span class="line">        #对******进行负载均衡</span><br><span class="line">        location ~ .*.(php|php5)?$</span><br><span class="line">        &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            include fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #图片缓存时间设置</span><br><span class="line">        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 10d;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #JS和CSS缓存时间设置</span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #日志格式设定</span><br><span class="line">        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><br><span class="line">        #$remote_user：用来记录客户端用户名称；</span><br><span class="line">        #$time_local： 用来记录访问时间与时区；</span><br><span class="line">        #$request： 用来记录请求的url与http协议；</span><br><span class="line">        #$status： 用来记录请求状态；成功是200，</span><br><span class="line">        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span><br><span class="line">        #$http_referer：用来记录从那个页面链接访问过来的；</span><br><span class="line">        #$http_user_agent：记录客户浏览器的相关信息；</span><br><span class="line">        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span><br><span class="line">        log_format access &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">        &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">        &#39;&quot;$http_user_agent&quot; $http_x_forwarded_for&#39;;</span><br><span class="line">         </span><br><span class="line">        #定义本虚拟主机的访问日志</span><br><span class="line">        access_log  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;host.access.log  main;</span><br><span class="line">        access_log  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;host.access.404.log  log404;</span><br><span class="line">         </span><br><span class="line">        #对 &quot;&#x2F;connect-controller&quot; 启用反向代理</span><br><span class="line">        location &#x2F;connect-controller &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">             </span><br><span class="line">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">             </span><br><span class="line">            #以下是一些反向代理的配置，可选。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">            #允许客户端请求的最大单文件字节数</span><br><span class="line">            client_max_body_size 10m;</span><br><span class="line"></span><br><span class="line">            #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span><br><span class="line">            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span><br><span class="line">            client_body_buffer_size 128k;</span><br><span class="line"></span><br><span class="line">            #表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><br><span class="line">            proxy_intercept_errors on;</span><br><span class="line"></span><br><span class="line">            #后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class="line">            #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">            proxy_connect_timeout 90;</span><br><span class="line"></span><br><span class="line">            #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span><br><span class="line">            proxy_send_timeout 90;</span><br><span class="line"></span><br><span class="line">            #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span><br><span class="line">            proxy_read_timeout 90;</span><br><span class="line"></span><br><span class="line">            #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span><br><span class="line">            proxy_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">            #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class="line">            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><br><span class="line">            proxy_buffers 4 32k;</span><br><span class="line"></span><br><span class="line">            #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">            proxy_busy_buffers_size 64k;</span><br><span class="line"></span><br><span class="line">            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><br><span class="line">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">            proxy_temp_file_write_size 64k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        #本地动静分离反向代理配置</span><br><span class="line">        #所有jsp的页面均交由tomcat或resin处理</span><br><span class="line">        location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、基本功能："><a href="#三、基本功能：" class="headerlink" title="三、基本功能："></a>三、基本功能：</h2><h3 id="A、代理功能："><a href="#A、代理功能：" class="headerlink" title="A、代理功能："></a>A、代理功能：</h3><h4 id="1、介绍："><a href="#1、介绍：" class="headerlink" title="1、介绍："></a>1、介绍：</h4><p>Nginx 能够同时支持正向代理和反向代理，这两种代理模式的区别如下：</p><ul><li>正向代理发生在客户端，是客户端主动发起的代理。如我们不能直接访问某个服务器，但可以间接通过中间的代理服务器去进行访问，然后将访问结果再返回给我们。</li><li>反向代理发生在服务端，客户端并不知道发生了代理，示例如下。用户只知道将请求发送给 Nginx，但是并不知道请求被转发了，也不知道被转发给了哪一台应用服务器。实际上对于用户来说，他也没必要知道，因为请求结果都是相同的。</li></ul><h4 id="2、反向代理实现："><a href="#2、反向代理实现：" class="headerlink" title="2、反向代理实现："></a>2、反向代理实现：</h4><h5 id="a、单域名代理："><a href="#a、单域名代理：" class="headerlink" title="a、单域名代理："></a>a、单域名代理：</h5><p>　　实现效果：打开浏览器，在浏览器地址栏输入地址<span><a href="http://www.123.com">www.123.com</a></span>跳转到 liunx 系统 tomcat 主页面中</p><p><strong>①、修改tomcat：</strong></p><p>　　在 liunx 系统安装 tomcat，使用默认端口 8080，我这里8080被其他应用占用，所以我已修改端口为8081。在conf目录下的server.xml配置文件中，如下，将port改为 8081，其实下面也有类似的Connector 标签，但是要看protocol协议为HTTP/1.1的标签修改即可。最后记得开放端口，</p><p><strong>②、修改电脑Host文件：</strong></p><p><strong>③、测试：</strong></p><p>　　如上配置，我们监听 80 端口，访问域名为 <a href="http://www.123.com，不加端口号时默认为">www.123.com，不加端口号时默认为</a> 80 端口，故 访问该域名时会跳转到 127.0.0.1:8081 路径上。在浏览器端输入 <a href="http://www.123.com">www.123.com</a> 后，界面将会跳向Tomcat界面。原理图如下：</p><h5 id="b、多域名代理："><a href="#b、多域名代理：" class="headerlink" title="ｂ、多域名代理："></a>ｂ、多域名代理：</h5><p><strong>①、效果：</strong></p><p>使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中，nginx 监听端口为 9001</p><p>　　访问  <a href="http://127.0.0.1:9001/edu/">http://127.0.0.1:9001/edu/</a> 　直接跳转到 127.0.0.1:8081<br>　　访问 <a href="http://127.0.0.1:9001/vod/">http://127.0.0.1:9001/vod/</a> 　直接跳转到 127.0.0.1:8082</p><p><strong>②、准备工作：</strong></p><p>　　准备两个 tomcat，一个 8081 端口，一个 8082 端口。编辑配置文件 ：/conf/server.xml 文件，修改相应的端口。修改完成并准备两个不同的测试页面。记得开放相应端口，tomcat8081端口：8081，tomcat8082端口：8082</p><p><strong>③、修改配置文件和测试：</strong></p><h3 id="B、负载均衡："><a href="#B、负载均衡：" class="headerlink" title="B、负载均衡："></a>B、负载均衡：</h3><h4 id="1、介绍：-1"><a href="#1、介绍：-1" class="headerlink" title="1、介绍："></a>1、介绍：</h4><p>　　单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上。将负载分发到不同的服务器，也就是我们所说的负载均衡。</p><h4 id="2、配置实现："><a href="#2、配置实现：" class="headerlink" title="2、配置实现："></a><strong>2、配置实现：</strong></h4><p>　　准备两台 tomcat 服务器，一台 8080，一台 8081。在两台 tomcat 里面 webapps 目录中，创建名称是 edu 文件夹，在 edu 文件夹中创建。页面 a.html，用于测试。页面内容可以不一样。用于辨别是否为同一个服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 这里指令块的名称可以随意指定，只要和下面的proxy_pass的值相同即可，通常配置为项目名</span><br><span class="line">upstream myserver &#123;  </span><br><span class="line">    server 208.208.128.122:8081; # 配置服务器的ip和端口</span><br><span class="line">    server 208.208.128.122:8082; #　未配置权重为轮询</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;; # 监听外部的端口号</span><br><span class="line">    server_name 192.168.0.226; # 域名或 ip </span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123; # 访问路径配置</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;myserver; # 对应上面的值</span><br><span class="line">        index  index.html index.htm; # 默认首页 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、策略介绍："><a href="#3、策略介绍：" class="headerlink" title="3、策略介绍："></a>3、策略介绍：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 权重配置方式：  </span><br><span class="line">upstream item &#123; # item名字可以自定义</span><br><span class="line">    server 192.168.101.60:81 weight&#x3D;1; </span><br><span class="line">    server 192.168.101.77:80 weight&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line"># weight的值越高被派发请求的概率也就越高，可以根据服务器配置的不同来设置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 哈希分配，</span><br><span class="line">upstream item &#123; # item名字可以自定义</span><br><span class="line">ip_hash;</span><br><span class="line">    server 192.168.101.60:81;</span><br><span class="line">    server 192.168.101.77:80;</span><br><span class="line">&#125;</span><br><span class="line"># 原理：他的根据客户端IP来分配服务器，比如我第一次访问请求被派发给了192.168.101.60这台服务器,那么我之后的请求就都会发送这台服务器上，这样的话session共享的问题也就解决了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 最少连接分配</span><br><span class="line">upstream item &#123; # item名字可以自定义</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.101.60:81;</span><br><span class="line">    server 192.168.101.77:80;</span><br><span class="line">&#125;</span><br><span class="line"># 原理：根据上添加的服务器判断哪台服务器分的连接最少就把请求给谁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 负载均衡响应时间最短算法，即利用插件，第三方方式，需要安装fair模块</span><br><span class="line">upstream webserver &#123;</span><br><span class="line">    server 10.18.14.59:8080;</span><br><span class="line">    server 10.18.14.109:8080;</span><br><span class="line">    server 10.18.3.197:8080;</span><br><span class="line">    fair;    #实现响应时间短的优先分配</span><br><span class="line">&#125;</span><br><span class="line">#　由于采用fair负载策略，配置weigth参数改变负载权重将无效。</span><br><span class="line"></span><br><span class="line"># 负载均衡url_hash算法</span><br><span class="line">upstream webserver &#123;</span><br><span class="line">    hash $request_uri;    #实现每个url定向到同一个后端服务器</span><br><span class="line">    server 10.18.14.59:8080;</span><br><span class="line">    server 10.18.14.109:8080;</span><br><span class="line">    server 10.18.3.197:8080;</span><br><span class="line">&#125;</span><br><span class="line">#　按请求url的hash结果来分配请求，使每个url定向到同一个后端服务器，服务器做缓存时比较有效。1.7.2版本以后，url_hash模块已经集成到．</span><br><span class="line"></span><br><span class="line">配置语法格式： server ip:端口 参数，常见参数有以下几个，具体参考官方文档：</span><br><span class="line">    weight 权重　　# weight &#x3D; 数值 (值越高被选中的概率也就越高)   </span><br><span class="line">    max_fails 失败多少次踢出队列　　# max_fails &#x3D; 数值</span><br><span class="line">    fail_timeout 踢出队列后重新探测时间  # fail_timeout &#x3D; 60s (s &#x3D; 秒)    </span><br><span class="line">    max_conns 最大连接数　# max_conns &#x3D; 800为防止单机性能过载可以根据实际情况设置</span><br><span class="line">    backup　备份机，所有服务器挂了之后才会生效</span><br><span class="line">    </span><br><span class="line">ｅｇ：server 192.168.0.100:8080 weight&#x3D;2 max_fails&#x3D;3 fail_timeout&#x3D;15;</span><br></pre></td></tr></table></figure><h3 id="C、动静分离："><a href="#C、动静分离：" class="headerlink" title="Ｃ、动静分离："></a>Ｃ、动静分离：</h3><h4 id="1、概念介绍："><a href="#1、概念介绍：" class="headerlink" title="1、概念介绍："></a>1、概念介绍：</h4><p>　　Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx</p><p>处理静态页面，Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种，</p><p>　　一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；</p><p>　　另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。</p><p>　　具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p><h4 id="２、配置实现："><a href="#２、配置实现：" class="headerlink" title="２、配置实现："></a>２、配置实现：</h4><p><strong>①、准备工作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">upstream taobaohost&#123; # 负载均衡</span><br><span class="line">         server 192.168.10.191:8081 weight&#x3D;8; # 指向Tomcat</span><br><span class="line">         server 192.168.10.191:8082 weight&#x3D;2; # 指向Tomcat</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">       listen   80;</span><br><span class="line">       server_name www.taobao.com; # 代理域名</span><br><span class="line">       location &#x2F; &#123;        # 处理动态资源</span><br><span class="line">           proxy_pass http:&#x2F;&#x2F;taobaohost;</span><br><span class="line">    &#125;</span><br><span class="line">    # 处理静态资源</span><br><span class="line">       location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff) &#123;</span><br><span class="line">          root &#x2F;servers&#x2F;taobao&#x2F;static;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　由于还没有创建静态资源的目录，所以此时打开域名，网页会出现版式错乱。这是因为访问后端服务时，因为需要加载静态资源文件，就触发了静态资源的访问规则，这个时候就会去 /servers/taobao/static 目录下面找，但实际上tomcat所需要的静态资源并不在该目录下，所以就找不到该资源，页面样式资源文件找不到报404也就不足为奇了。但是后端服务是可以正常访问的。通常情况下动静分离后的网站架构，后端只提供接口的访问服务，这里只是为了演示效果。</p><p>　　解决这个问题，只需要创建存放静态资源的目录，并将静态资源放在该目录中。再次打开 网址的时候就正常了</p><blockquote><p>参考博客：</p><p><a href="https://blog.csdn.net/qq_40036754/article/details/102463099">https://blog.csdn.net/qq_40036754/article/details/102463099</a></p><p><a href="https://juejin.im/post/5e10998f5188253a937f417a#heading-20">https://juejin.im/post/5e10998f5188253a937f417a#heading-20</a></p><p><a href="https://blog.csdn.net/zhaoxixc/article/details/84867695?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-5">https://blog.csdn.net/zhaoxixc/article/details/84867695?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-5</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Nginx-介绍：&quot;&gt;&lt;a href=&quot;#一、Nginx-介绍：&quot; class=&quot;headerlink&quot; title=&quot;一、Nginx 介绍：&quot;&gt;&lt;/a&gt;一、Nginx 介绍：&lt;/h2&gt;&lt;h3 id=&quot;A、概述：&quot;&gt;&lt;a href=&quot;#A、概述：&quot; class
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/JavaWeb/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
</feed>
